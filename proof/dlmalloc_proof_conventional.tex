\documentclass[10pt,a4paper,twoside]{report}
\usepackage{a4wide}

\usepackage{JohnMath}
\usepackage{mapsto}

\usepackage[svgnames]{xcolor}
% \usepackage{MnSymbol}


% CODE LISTINGS
\usepackage{listings}
\lstset{
  language=C,
  columns=[l]fullflexible,
  mathescape=true,
  basicstyle=\ttfamily\color{Purple},
  showstringspaces=false,
  commentstyle=\color{DarkGreen}, 
  numbers=none, 
  escapechar=£,
  escapebegin=\normalsize\rmfamily\color{Black}
}

% SPECIFICATIONS
\newcommand{\ml}[2][t]{\mbox{\mdseries\begin{tabular}[#1]{@{}L@{}}#2\end{tabular}}}
\newcommand{\ass}[1]{\ensuremath{{\color{blue}\left\{\ml[c]{#1}\right\}}}}
\newcommand{\seqspec}[3]{\ass{#1}\,{\mbox{{\tt #2}}}\,\ass{#3}}
\newcommand{\Seqspec}[3]{\multicolumn{2}{l}{$\ass{#1}$ {#2} $\ass{#3}$}}
\newcommand{\comm}[1]{\vspace{-2pt}%
    \begin{list}{/$*$}{%
        \topsep=5pt%
        \leftmargin=3cm%
      }\item #1 \hfill$*$/\end{list}%
}

\newcommand{\checkthis}{$^{\rm [check\ this]}$}
\renewcommand{\floor}[2][]{\left\lfloor{#2}\right\rfloor_{#1}}
\renewcommand{\ceil}[2][]{\left\lceil{#2}\right\rceil_{#1}}
\newcommand{\floorpow}[1]{\llfloor{#1}\rrfloor}
\newcommand{\fracpow}[1]{\{\hspace{-3pt}\{{#1}\}\hspace{-3pt}\}}

% STATUS FLAGS
\newcommand{\setC}{\raisebox{1.5pt}{$\blacktriangledown$}}
\newcommand{\unsetC}{\raisebox{1.5pt}{$\triangledown$}}
\newcommand{\setP}{{\blacktriangle}}
\newcommand{\unsetP}{{\triangle}}

% BIT OPERATIONS
\newcommand{\AND}{\mathbin{\texttt{\&}}}
\newcommand{\OR}{\mathbin{\texttt{|}}}
\newcommand{\NOT}{\mathbin{\textasciitilde}}
\newcommand{\SHIFTRIGHT}{\mathbin{\texttt{>}\hspace{-1pt}\texttt{>}}}
\newcommand{\SHIFTLEFT}{\mathbin{\texttt{<}\hspace{-1pt}\texttt{<}}}



\newcommand{\rsem}[1]{{(\![}{#1}{]\!)}}
\newcommand{\iterstar}[2][]{\text{\LARGE $*$}^{#1}_{#2}}

\newcommand{\defined}{\mathop{\text{def}}}

\newcommand{\SET}[2]{\left\{\begin{array}{@{}l|l@{}} #1 & #2 \end{array}\right\}}

\newenvironment{mapping}{\left\{ \begin{array}{@{}r@{\,↦\,}l@{}}}{\end{array}\right\}}

%\newcommand{\block}[1]{\smash{\overbracket[0.5pt][2pt]{\underscore\,\ldots\,\underscore}^{#1}}}

\newcommand{\ret}{\texttt{ret}}

\newcommand{\malloc}{{\tt malloc}}
\newcommand{\sbrk}{{\tt sbrk}}
\newcommand{\free}{{\tt free}}
\newcommand{\ls}[2][]{#1 \twoheadrightarrow #2}
\newcommand{\A}[2][]{#1 \mathbin{\smash{\underset{\raisebox{3.5pt}{\smash{\sf\scriptsize a}}}{\rightarrow}}} #2}
\newcommand{\U}[2][]{#1 \mathbin{\smash{\underset{\raisebox{3.5pt}{\smash{\sf\scriptsize u}}}{\rightarrow}}} #2}
\newcommand{\B}[2][]{#1 {\rightarrow} #2}
\newcommand{\E}[2]{#2 \mathbin{\raisebox{2pt}{$\curvearrowleft$}} #1}
\newcommand{\s}{{\tt s}}
\renewcommand{\t}{{\tt t}}
\newcommand{\temp}{{\tt temp}}
\newcommand{\p}{{\tt p}}
\newcommand{\q}{{\tt q}}
\renewcommand{\v}{{\tt v}}
\newcommand{\brk}{\mathop{\emph{brk}}}
\newcommand{\brka}{\mathop{\emph{brka}}}
\newcommand{\n}{{}\\{} \hfill }
\newcommand{\nw}{{\tt nw}}
\newcommand{\ap}{{\tt ap}}
\newcommand{\nbytes}{{\tt nbytes}}
\newcommand{\WORD}{{\tt WORD}}
\newcommand{\mathceil}[1]{\left\lceil#1\right\rceil}
\newcommand{\ptoU}{\mathbin{↦_{\sf u}}}
\newcommand{\ptoA}{\mathbin{↦_{\sf a}}}
\newcommand{\ptoS}{\mathbin{↦_{\sf s}}}




\title{A proof of Doug Lea's memory manager}
\author{John Wickerson}
\date{\today}

\begin{document}

\maketitle
\pagestyle{headings}

\chapter{Glossary of macros, typedefs and minor routines}\label{chap:glossary}

\renewcommand{\arraystretch}{1.2}

\begin{tt}
\begin{tabular}{l@{ $=$ }L}
MALLOC\_ALIGNMENT & 8 \\
MAX\_SIZE\_T & FFFF\ FFFF_h \\
SIZE\_T\_SIZE & 4 \\
SIZE\_T\_BITSIZE & 32 \\
SIZE\_T\_ZERO & 0 \\
SIZE\_T\_ONE & 1 \\
SIZE\_T\_TWO & 2 \\
SIZE\_T\_FOUR & 4 \\
TWO\_SIZE\_T\_SIZES & 8 \\
FOUR\_SIZE\_T\_SIZES & 16 \\
SIX\_SIZE\_T\_SIZES & 24 \\
HALF\_MAX\_SIZE\_T & 7FFF\ FFFF_h \\
CHUNK\_ALIGN\_MASK & 111_b \\
mchunk & \text{struct malloc\_chunk} \\
mchunkptr & \text{mchunk*} \\
sbinptr & \text{mchunk*} \\
bindex\_t & \text{unsigned int} \\
binmap\_t & \text{unsigned int} \\
flag\_t & \text{unsigned int} \\
MCHUNK\_SIZE & 16 \\
CHUNK\_OVERHEAD & 4 \\
MIN\_CHUNK\_SIZE & 16 \\
chunk2mem(p) & {\tt p} + 8 \\
mem2chunk(mem) & {\tt mem} - 8 \\
MAX\_REQUEST & 2^{32}-63 \\
MIN\_REQUEST & 11 \\
pad\_request(req) & \ceil[8]{{\tt req}+4} \\
request2size(req) & \max\{16, \ceil[8]{{\tt req}+4}\} \\
\end{tabular}

\begin{tabular}{l@{ $=$ }L}
PINUSE\_BIT & 1_b \\
CINUSE\_BIT & 10_b \\
FLAG4\_BIT & 100_b \\
INUSE\_BITS & 11_b \\
FLAG\_BITS & 111_b \\
cinuse(p) & [{\tt p}_{[1]}] == 1 \\
pinuse(p) & [{\tt p}_{[0]}] == 1 \\
is\_inuse(p) & \texttt{is\_mmapped(p)} ∨ \texttt{cinuse(p)} \\
is\_mmapped(p) & [{\tt p}_{[1,0]}] == 00 \\
chunksize(p) & [({\tt p}+1)_{[31..3]}000] \\
\Seqspec{{\tt p}_{[0]} ↦ \underscore}{clear\_pinuse(p)}{{\tt p}_{[0]} ↦ 0} \\
chunk\_plus\_offset(p,s) & p + s \\
chunk\_minus\_offset(p,s) & p - s \\
next\_chunk(p) & next({\tt p}) \\
prev\_chunk(p) & prev({\tt p}) \\
next\_pinuse(p) & flags(next({\tt p})) = \_\setP \\
get\_foot(p,s) & prev\_foot({\tt p} + {\tt s}) \\
\Seqspec{prev\_foot({\tt p} + {\tt s}) = \_ }{set\_foot(p,s)}{prev\_foot({\tt p} + {\tt s}) = {\tt s}} \\
\Seqspec{size({\tt p})=\_ ∧ flags({\tt p})=\_\_ {}\\{} ∧ prev\_foot({\tt p}+{\tt s})=\_}{set\_size\_and\_pinuse\_of\_free\_chunk(p,s)}{size({\tt p})={\tt s} ∧ flags({\tt p})=\unsetC\setP {}\\{} ∧ prev\_foot(next({\tt p}))={\tt s}} \\
\Seqspec{size({\tt p})=\_ ∧ flags({\tt p})=\_\_ {}\\{} ∧ prev\_foot({\tt p}+{\tt s})=\_ {}\\{} ∧ flags({\tt p}+{\tt s})=\_\_}{set\_free\_with\_pinuse(p,s,n)}{size({\tt p})={\tt s} ∧ flags({\tt p})=\unsetC\setP {}\\{} ∧ prev\_foot(next({\tt p}))={\tt s} {}\\{} ∧ flags(next({\tt p}))=\_\unsetP} \\
tchunk & \text{malloc\_tree\_chunk} \\
tchunkptr & \text{tchunk*} \\
tbinptr & \text{tchunk*} \\
leftmost\_child(t) & \left\{\begin{array}{ll}child_0({\tt *t}) & \textrm{if $child_0({\tt *t}) ≠ 0$} \\ child_1({\tt *t}) & \textrm{otherwise}\end{array}\right. \\
NSMALLBINS & 32 \\
NTREEBINS & 32 \\
SMALLBIN\_SHIFT & 3 \\
SMALLBIN\_WIDTH & 8 \\
TREEBIN\_SHIFT & 8 \\
MIN\_LARGE\_SIZE & 256 \\
MAX\_SMALL\_SIZE & 255 \\
MAX\_SMALL\_REQUEST & 244 \\
mstate & \text{struct malloc\_state} \\
mparams & \text{struct malloc\_params} \\
is\_small(s) & {\tt s} < 256 \\
small\_index(s) & \floor{{\tt s}/8} \\
small\_index2size(i) & 8×{\tt i} \\
MIN\_SMALL\_INDEX & 2 \\
\end{tabular}

\begin{tabular}{l@{ $=$ }L}
\Seqspec{{\tt smallbins}[2{\tt i}+2]↦C_1 * {\tt smallbins}[2{\tt i}+3]↦C_2}{x := smallbin\_at(M,i)}{{\tt x}.{\tt fd} ↦ C_1 * {\tt x}.{\tt bk} ↦ C_2} \\
treebin\_at(M,i) & {\tt treebins}[{\tt i}] \\
\Seqspec{{\tt I}=\_}{compute\_tree\_index(S,I)}{{\tt I}=\left\{\begin{array}{ll} 0 & \textrm{if ${\tt S}<256$} \\ 31 & \textrm{if ${\tt S}>2^{24}$} \\ 2(\log_2{\floorpow{{\tt S}}-8}) & \textrm{if $0≤\fracpow{{\tt S}} < \tfrac{1}{2}\floorpow{{\tt S}}$} \\ 2(\log_2{\floorpow{{\tt S}}-8})+1 & \textrm{if $\tfrac{1}{2}\floorpow{{\tt S}} ≤\fracpow{{\tt S}} < \floorpow{{\tt S}}$} \end{array}\right.}\\ 
bin\_for\_tree\_index(i) & \left\{\begin{array}{ll}31 & \textrm{if ${\tt i}=31$} \\ \floor{{\tt i}/2}+6 & \textrm{otherwise}\end{array}\right. \\
leftshift\_for\_tree\_index(i) & \left\{\begin{array}{ll}0 & \textrm{if ${\tt i}=31$} \\ 25-\floor{{\tt i}/2} & \textrm{otherwise}\end{array}\right. \\
minsize\_for\_tree\_index(i) & \left\{\begin{array}{ll}2 \SHIFTLEFT (\floor{{\tt i}/2}+7) & \textrm{if ${\tt i}$ even} \\ 3 \SHIFTLEFT (\floor{{\tt i}/2}+7) & \textrm{if ${\tt i}$ odd}\end{array}\right. \\
idx2bit(i) & 1 \SHIFTLEFT {\tt i} \\
\Seqspec{{\tt smallmap}[{\tt i}]=\_}{mark\_smallmap(M,i)}{{\tt smallmap}[{\tt i}]=1} \\
\Seqspec{{\tt smallmap}[{\tt i}]=\_}{clear\_smallmap(M,i)}{{\tt smallmap}[{\tt i}]=0} \\
smallmap\_is\_marked(M,i) & {\tt smallmap}[{\tt i}]=1 \\
\Seqspec{{\tt treemap}[{\tt i}]=\_}{mark\_treemap(M,i)}{{\tt treemap}[{\tt i}]=1} \\
\Seqspec{{\tt treemap}[{\tt i}]=\_}{clear\_treemap(M,i)}{{\tt treemap}[{\tt i}]=0} \\
treemap\_is\_marked(M,i) & {\tt treemap}[{\tt i}]=1 \\
least\_bit(x) & \left\{\begin{array}{ll}\mathbf{0} \stackrel{i}{1}\mathbf{0} & \textrm{if ${\tt x}_i=1 ∧ ∀j<i．{\tt x}_j=0 \}$} \\ \mathbf{0} & \textrm{if {\tt x}=0} \end{array}\right. \\
left\_bits(x) & \left\{\begin{array}{ll}\mathbf{1} \stackrel{i}{0}\mathbf{0} & \textrm{if ${\tt x}_i=1 ∧ ∀j<i．{\tt x}_j=0 \}$} \\ \mathbf{0} & \textrm{if ${\tt x}=0$}\end{array}\right. \\
same\_or\_left\_bits(x) & \left\{\begin{array}{ll}\mathbf{1} \stackrel{i}{1}\mathbf{0} & \textrm{if ${\tt x}_i=1 ∧ ∀j<i．{\tt x}_j=0 \}$} \\ \mathbf{0} & \textrm{if ${\tt x}=0$}\end{array}\right. \\
\Seqspec{{\tt I}=\_}{compute\_bit2idx(X,I)}{{\tt X≠0} ⇒ {\tt I}=\log_2 {\tt X}} \\
\Seqspec{p}{mark\_inuse\_foot(M,p,s)}{p} \\
\Seqspec{size({\tt p})=\_ ∧ flags({\tt p}) = \_P {}\\{} ∧ flags({\tt p}+{\tt s}) = C\_ }{set\_inuse(M,p,s)}{size({\tt p})={\tt s} ∧ flags({\tt p}) = \setC P {}\\{} ∧ flags(next({\tt p})) = C\setP } \\
\Seqspec{size({\tt p})=\_ ∧ flags({\tt p}) = \_\_ {}\\{} ∧ flags({\tt p}+{\tt s}) = C\_ }{set\_inuse\_and\_pinuse(M,p,s)}{size({\tt p})={\tt s} ∧ flags({\tt p}) = \setC\setP {}\\{} ∧ flags(next({\tt p})) = C\setP } \\
\Seqspec{size({\tt p})=\_ {}\\{} ∧ flags({\tt p}) = \_\_}{set\_inuse\_and\_pinuse\_of\_inuse\_chunk(M,p,s)}{size({\tt p})={\tt s} {}\\{} ∧ flags({\tt p}) = \setC\setP} \\
\end{tabular}
\end{tt}

\chapter{State}

\newcommand{\fd}[2]{{#1} \mapstosup{{\sf fd}} {#2}}
\newcommand{\bk}[2]{{#1} \mapstosup{{\sf bk}} {#2}}
\newcommand{\prevfoot}[2]{{#1} \mapstosup{{\sf prevfoot}} {#2}}
\newcommand{\fdbk}{}
\renewcommand{\size}[2]{{#1} \mapstosup{{\sf size}} {#2}}
\newcommand{\pinuse}[2]{{#1} \mapstosup{{\sf pinuse}} {#2}}
\newcommand{\cinuse}[2]{{#1} \mapstosup{{\sf cinuse}} {#2}}
\newcommand{\smallsize}[1]{\lvert{#1}\rvert}
\newcommand{\treesize}[1]{\lVert{#1}\rVert}
\newcommand{\arena}[1]{{\it arena}({#1})}
\newcommand{\sorted}[2]{{\it sorted}({#1},{#2})}
\newcommand{\coallesced}[1]{{\it coallesced}({#1})}
\newcommand{\state}[1]{{\it state}({#1})}
\newcommand{\invariant}{{\it invariant}}
\newcommand{\token}[2]{{\it token}({#1},{#2})}
\newcommand{\block}[4][]{{\it block}^{#1}\ifthenelse{\equal{#2}{}}{}{({#2},{#3},{#4})}}
\newcommand{\ublock}[4][]{{\it ublock}^{#1}\ifthenelse{\equal{#2}{}}{}{({#2},{#3},{#4})}}
\newcommand{\ablock}[4][]{{\it ablock}^{#1}\ifthenelse{\equal{#2}{}}{}{({#2},{#3},{#4})}}
\newcommand{\bin}[3]{{\it bin}({#1},{#2},{#3})}
\newcommand{\bnode}[5][]{\ifthenelse{\equal{#1}{}}{{\it bnode}\,{#2}\,}{({\it bnode}\,{#2})^{#1}}({#3},{#4},{#5})}
\newcommand{\smallbin}[2]{{\it smallbin}_{#1}({#2})}
\newcommand{\treebin}[2]{{\it treebin}_{#1}({#2})}
\newcommand{\uplusminus}{\mathbin{{\uplus}\!{-}}}


Shorthand:
\[
\begin{array}{rcl}
\smallsize i &\eqdef& \{8i\} \\
\treesize i &\eqdef& \texttt{compute\_tree\_index}^{-1}(i) \\
{\sf w} &\eqdef& 4 \\
x \uplus y &\eqdef&  \begin{cases} x ∪ y & \text{if $x ∩ y = \{\}$} \\ \text{undefined} & \text{otherwise}\end{cases}\\
x \uplusminus y &\eqdef&  \begin{cases} x-y & \text{if $y ⊆ x$} \\ \text{undefined} & \text{otherwise}\end{cases}
\end{array}
\]

\noindent Predicates:

\[
\begin{array}{rcl}
\prevfoot{x}{s} &\eqdef& x ↦ s
\\
\size{x}{s} &\eqdef& ∃n．(x+1{\sf w}) ↦_{[31..3]} n  *  8n=s
\\
\pinuse{x}{b} &\eqdef& (x+1{\sf w}) ↦_{[0]} b
\\
\cinuse{x}{b} &\eqdef& (x+1{\sf w}) ↦_{[1]} b
\\
\fd{x}{y} &\eqdef& x+2{\sf w} ↦ y 
\\
\bk{x}{y} &\eqdef& x+3{\sf w} ↦ y 
\\
\ublock{x}{y}{B} &\eqdef& \ml{{\sf let} s=y-x {\sf in} ∃n．B = \{x+2{\sf w} \ptoU n{\sf w}\}  *  (n+1){\sf w}=s {}\\{}
*  \frac12(\size{x}{s})  *  \pinuse{y}{0}  *  \cinuse{x}{0} {}\\{}
*  s≥4{\sf w}  *  \iterstar[s/{\sf w}]{i=4}．x+i{\sf w}↦\underscore  *  \prevfoot{y}{s} }
\\
\ablock{x}{y}{B} &\eqdef& \ml{{\sf let} s=y-x {\sf in} ∃n．B = \{x+2{\sf w} \ptoA n{\sf w}\}  *  (n+1){\sf w}≤s {}\\{}
*  \frac12(\size{x}{s})  *  \pinuse{y}{1}  *  \cinuse{x}{1} {}\\{}
*  s≥4{\sf w}  *  \iterstar[s/{\sf w}+1]{i=n+2}．x+i{\sf w}↦\underscore } 
\\
\block{}{}{} &\eqdef& {\ublock{}{}{}} ∨ {\ablock{}{}{}} 
\\
\bin{S}{x}{U} &\eqdef& \ml{ (U=\{\}  *  \fd{x}{\underscore}  *  \bk{x}{\underscore}) {}\\{}
∨ (∃y．\fd{x}{y}  * \bk{y}{x}  *  \bnode[*]{S}{y}{x}{U}) } 
\\
\bnode{S}{x}{y}{U} &\eqdef& \ml{∃s．\fd{x}{y}  * \bk{y}{x}  *  U=\{x+2{\sf w} ↦ s-1{\sf w}\}  *  \frac12(\size{x}{s})  *  s ∈ S }
\\
\sorted{L}{\sqsubseteq} &\eqdef& ∀i,j．i≤j ⇒ L(i) \sqsubseteq L(j)
\\ 
\coallesced{B} &\eqdef& ∃L．\ran{L} = B  *  \sorted{L}{≤_1}  *  ∄i．(L(i))_3 = (L(i+1))_3 = {\sf u}
\\
\arena{B} &\eqdef& \ml{\coallesced{B}  *  \pinuse{\tt start}{1}  *  \prevfoot{\tt start}{\underscore} {}\\{} *  \block[*]{{\tt start}}{{\tt top}}{B}  *  \ublock{{\tt top}}{{\tt top}+{\tt topsize}}{\underscore}} 
\\
\smallbin{i}{U} &\eqdef& i∈[0,32)  *  \bin{{\smallsize i}}{{\tt smallbin}+2i{\sf w}}{ U}  *  {\tt smallmap}_{[i]}=(U≠\{\}) 
\\
\treebin{i}{U} &\eqdef& i∈[0,32)  *  \bin{{\treesize i}}{{\tt treebins}+i{\sf w}}{U}  *  {\tt treemap}_{[i]}=(U≠\{\}) 
\\
\state{A} &\eqdef& ∃\{U_i\mid i∈[0,64)\}．\ml{\arena{A_{\sf a} \uplus (\biguplus_{i=0}^{64}．U_i)_{\sf u}}  *  \texttt{least\_addr}=5{\sf w} {}\\{}
*   \iterstar[32]{i=0}．\smallbin{i}{U_i}  *  \iterstar[32]{i=0}．\treebin{i}{U_{i+32}}} 
\\
\invariant &\eqdef& \boxed{∃A．\state{A}} 
\\
\token{x}{n} &\eqdef& \boxed{∃A．\state{A \uplus \{x↦n\}}}  *  \frac12(\size{x-2{\sf w}}{\underscore})
\end{array}
\]

\begin{lemma}\label{lem:coallesced} The assertion
\[
\block{x}{y}{B_1}  *  \ablock{y}{z}{B_2}  *  \coallesced{B_1\uplus B_2 \uplus B_3}\]
implies
\[
\ublock{x}{y}{B_1}  *  \ablock{y}{z}{B_2}  *  \coallesced{B_1\uplus B_2 \uplus B_3}.
\]
\end{lemma}

\chapter{Auxilliary operations}\label{chap:smallbins_and_trees}

\section{\tt set\_inuse\_and\_pinuse}

Specification:
\begin{lstlisting}
£\ass{\size{\tt p}{\underscore}  *  \pinuse{\tt p}{\underscore}  *  \cinuse{\tt p}{\underscore}  *  \pinuse{{\tt p}+{\tt s}}{\underscore}}£
set_inuse_and_pinuse(M,p,s)
£\ass{\size{\tt p}{\tt s}  *  \pinuse{\tt p}{1}  *  \cinuse{\tt p}{1}  *  \pinuse{{\tt p}+{\tt s}}{1}}£
\end{lstlisting}

\noindent Verification:
\begin{lstlisting}
£\ass{\size{\tt p}{\underscore}  *  \pinuse{\tt p}{\underscore}  *  \cinuse{\tt p}{\underscore}  *  \pinuse{{\tt p}+{\tt s}}{\underscore}}£
p->head = (s|PINUSE_BIT|CINUSE_BIT);
£\ass{\size{\tt p}{\tt s}  *  \pinuse{\tt p}{1}  *  \cinuse{\tt p}{1}  *  \pinuse{{\tt p}+{\tt s}}{\underscore}}£
((mchunkptr)(((char*)p) + s))->head |= PINUSE_BIT;
£\ass{\size{\tt p}{\tt s}  *  \pinuse{\tt p}{1}  *  \cinuse{\tt p}{1}  *  \pinuse{{\tt p}+{\tt s}}{1}}£
\end{lstlisting}

\section{\tt set\_size\_and\_pinuse\_of\_free\_chunk}

Specification:
\begin{lstlisting}
£\ass{\size{\tt p}{\underscore}  *  \pinuse{\tt p}{\underscore}  *  \cinuse{\tt p}{\underscore}  *  \prevfoot{{\tt p}+{\tt s}}{\underscore}}£
set_size_and_pinuse_of_free_chunk(p,s)
£\ass{\size{\tt p}{\tt s}  *  \pinuse{\tt p}{1}  *  \cinuse{\tt p}{0}  *  \prevfoot{{\tt p}+{\tt s}}{\tt s}}£
\end{lstlisting}

\noindent Verification:
\begin{lstlisting}
£\ass{\size{\tt p}{\underscore}  *  \pinuse{\tt p}{\underscore}  *  \cinuse{\tt p}{\underscore}  *  \prevfoot{{\tt p}+{\tt s}}{\underscore}}£
p->head = (s|PINUSE_BIT);
£\ass{\size{\tt p}{\tt s}  *  \pinuse{\tt p}{1}  *  \cinuse{\tt p}{0}  *  \prevfoot{{\tt p}+{\tt s}}{\underscore}}£
set_foot(p,s);
£\ass{\size{\tt p}{\tt s}  *  \pinuse{\tt p}{1}  *  \cinuse{\tt p}{0}  *  \prevfoot{{\tt p}+{\tt s}}{\tt s}}£
\end{lstlisting}

\section{\tt set\_size\_and\_pinuse\_of\_inuse\_chunk}

Specification:
\begin{lstlisting}
£\ass{\size{\tt p}{\underscore}  *  \pinuse{\tt p}{\underscore}  *  \cinuse{\tt p}{\underscore}}£
set_size_and_pinuse_of_inuse_chunk(M,p,s)
£\ass{\size{\tt p}{\tt s}  *  \pinuse{\tt p}{1}  *  \cinuse{\tt p}{1}}£
\end{lstlisting}

\noindent Verification:
\begin{lstlisting}
£\ass{\size{\tt p}{\underscore}  *  \pinuse{\tt p}{\underscore}  *  \cinuse{\tt p}{\underscore}}£
p->head = (s|PINUSE_BIT|CINUSE_BIT);
£\ass{\size{\tt p}{\tt s}  *  \pinuse{\tt p}{1}  *  \cinuse{\tt p}{1}}£
\end{lstlisting}


\section{\tt insert\_small\_chunk}

Specification:
\begin{lstlisting}
£\ass{\frac12(\size{{\tt P}}{ {\tt S}})  *  \fd{{\tt P}}{\underscore}  *  \bk{{\tt P}}{\underscore}  *  \smallbin{{⌊{\tt S}/8⌋}}{U}}£
insert_small_chunk(M,P,S) //mods={}
£\ass{\smallbin{{⌊{\tt S}/8⌋}}{U\uplus\{{\tt P}+2{\sf w}↦{\tt S}-1{\sf w}\}}}£
\end{lstlisting}

\noindent Verification:
\begin{lstlisting}
£\ass{\frac12(\size{{\tt P}}{ {\tt S}})  *  \fd{{\tt P}}{\underscore}  *  \bk{{\tt P}}{\underscore}  *  \smallbin{{⌊{\tt S}/8⌋}}{U}}£
bindex_t I  = small_index(S);
£\ass{∃B．\frac12(\size{{\tt P}}{ {\tt S}})  *  {\tt S} = 8{\tt I}  *  \fd{{\tt P}}{\underscore}  *  \bk{{\tt P}}{\underscore}  *  B = {\tt smallbin}+2{\tt I}{\sf w}  *  0≤{\tt I}<32{}\\{}
* \bin{{\smallsize {\tt I}}}{B}{U}  *  {\tt smallmap}_{[{\tt I}]}=(U≠\{\}) }£
mchunkptr B = smallbin_at(M, I);
£\ass{\frac12(\size{{\tt P}}{ {\tt S}})  *  {\tt S} = 8{\tt I}  *  \fd{{\tt P}}{\underscore}  *  \bk{{\tt P}}{\underscore}  *  {\tt B} = {\tt smallbin}+2{\tt I}{\sf w}   *  0≤{\tt I}<32 {}\\{}
* \bin{{\smallsize {\tt I}}}{{\tt B}}{U}  *  {\tt smallmap}_{[{\tt I}]}=(U≠\{\}) }£
mchunkptr F = B;
£\ass{∃F'．\frac12(\size{{\tt P}}{ {\tt S}})  *  {\tt S} = 8{\tt I}  *  \fd{{\tt P}}{\underscore}  *  \bk{{\tt P}}{\underscore} {}\\{}
*  {\tt B} = {\tt smallbin}+2{\tt I}{\sf w}  *  {\tt F}={\tt B}   *  0≤{\tt I}<32 {}\\{}
*  ((\fd{{\tt B}}{\underscore}  *  \bk{{\tt B}}{\underscore}  *  U=\{\}) {}\\{}
∨ (\fd{{\tt B}}{F'}  * \bk{F'}{{\tt B}}  *  \bnode[*]{{\smallsize {\tt I}}}{F'}{{\tt B}}{U})) {}\\{}
*  {\tt smallmap}_{[{\tt I}]}=(U≠\{\})  }£
//assert(S >= MIN_CHUNK_SIZE);
if (!smallmap_is_marked(M, I))
  £\ass{\frac12(\size{{\tt P}}{ {\tt S}})  *  {\tt S} = 8{\tt I}  *  \fd{{\tt P}}{\underscore}  *  \bk{{\tt P}}{\underscore}  *  {\tt B} = {\tt smallbin}+2{\tt I}{\sf w}  *  {\tt F}={\tt B}   *  0≤{\tt I}<32 {}\\{}
* \fd{{\tt B}}{\underscore}  *  \bk{{\tt F}}{\underscore}  *  \bnode[*]{{\smallsize {\tt I}}}{{\tt F}}{{\tt B}}{U}  *  {\tt smallmap}_{[{\tt I}]}=0  *  U=\{\} }£
  mark_smallmap(M, I);
  £\ass{\frac12(\size{{\tt P}}{ {\tt S}})  *  {\tt S} = 8{\tt I}  *  \fd{{\tt P}}{\underscore}  *  \bk{{\tt P}}{\underscore}  *  {\tt B} = {\tt smallbin}+2{\tt I}{\sf w}   *  0≤{\tt I}<32{}\\{}
* \fd{{\tt B}}{\underscore}  *  \bk{{\tt F}}{\underscore}  *  \bnode[*]{{\smallsize {\tt I}}}{{\tt F}}{{\tt B}}{U}  *  {\tt smallmap}_{[{\tt I}]}=1  }£
else //if (RTCHECK(ok_address(M, B->fd)))
  £\ass{∃F．\frac12(\size{{\tt P}}{ {\tt S}})  *  {\tt S} = 8{\tt I}  *  \fd{{\tt P}}{\underscore}  *  \bk{{\tt P}}{\underscore}  *  {\tt B} = {\tt smallbin}+2{\tt I}{\sf w}   *  0≤{\tt I}<32 {}\\{}
*  \fd{{\tt B}}{F}  *  \bk{F}{{\tt B}}  *  \bnode[*]{{\smallsize {\tt I}}}{F}{{\tt B}}{U}  *  {\tt smallmap}_{[{\tt I}]}=1  }£
  F = B->fd;
  £\ass{\frac12(\size{{\tt P}}{ {\tt S}})  *  {\tt S} = 8{\tt I}  *  \fd{{\tt P}}{\underscore}  *  \bk{{\tt P}}{\underscore}  *  {\tt B} = {\tt smallbin}+2{\tt I}{\sf w}   *  0≤{\tt I}<32 {}\\{}
* \fd{{\tt B}}{\underscore}  *  \bk{{\tt F}}{\underscore}  *  \bnode[*]{{\smallsize {\tt I}}}{{\tt F}}{{\tt B}}{U}  *  {\tt smallmap}_{[{\tt I}]}=1  }£
// else {
//   CORRUPTION_ERROR_ACTION(M);
// }
£\ass{∃i．\frac12(\size{{\tt P}}{ {\tt S}})  *  {\tt S} = 8i  *  \fd{{\tt P}}{\underscore}  *  \bk{{\tt P}}{\underscore}  *  {\tt B} = {\tt smallbin}+2i   *  0≤i<32{}\\{}
* \fd{{\tt B}}{\underscore}  *  \bk{{\tt F}}{\underscore}  *  \bnode[*]{{\smallsize i}}{{\tt F}}{{\tt B}}{U}  *  {\tt smallmap}_{[i]}=1}£
B->fd = P;
F->bk = P;
P->fd = F;
P->bk = B;
£\ass{∃i．\frac12(\size{{\tt P}}{ {\tt S}})  *  {\tt S} = 8i  *  {\tt B} = {\tt smallbin}+2i   *  0≤i<32 {}\\{}
*  \fd{{\tt B}}{{\tt P}}  * \bk{{\tt P}}{{\tt B}}  *  \fd{{\tt P}}{{\tt F}}  *  \bk{{\tt F}}{{\tt P}} {}\\{}
*  \bnode[*]{{\smallsize i}}{{\tt F}}{{\tt B}}{U}  *  {\tt smallmap}_{[i]}=1}£
£\ass{∃i．{\tt S} = 8i  *  {\tt B} = {\tt smallbin}+2i   *  0≤i<32  *  \fd{{\tt B}}{{\tt P}}  *  \bk{{\tt P}}{ {\tt B}} {}\\{}
*  \bnode[*]{{\smallsize i}}{{\tt P}}{{\tt B}}{U \uplus \{{\tt P}+2{\sf w} ↦ {\tt S}-1{\sf w}\}}  *  {\tt smallmap}_{[i]}=1}£
£\ass{∃i．{\tt S} = 8i   *  0≤i<32 {}\\{}
* \bin{{\smallsize i}}{{\tt smallbin}+2i}{U \uplus \{{\tt P}+2{\sf w} ↦ {\tt S}-1{\sf w}\}} {}\\{}
*  {\tt smallmap}_{[i]}=(U \uplus \{{\tt P}+2{\sf w} ↦ {\tt S}-1{\sf w}\}≠\{\})}£
£\ass{\smallbin{{⌊{\tt S}/8⌋}}{U\uplus\{{\tt P}+2{\sf w}↦{\tt S}-1{\sf w}\}}}£
\end{lstlisting}


\section{{\tt unlink\_small\_chunk}}

Specification:
\begin{lstlisting}
£\ass{\smallbin{{⌊{\tt S}/8⌋}}{U\uplus\{{\tt P}+2{\sf w}↦{\tt S}-1{\sf w}\}}}£
unlink_small_chunk(M,P,S) //mods={}
£\ass{\frac12(\size{{\tt P}}{ {\tt S}})  *  \fd{{\tt P}}{\underscore}  *  \bk{{\tt P}}{\underscore}  *  \smallbin{{⌊{\tt S}/8⌋}}{U}}£
£\ £
\end{lstlisting}

\noindent Verification:
\begin{lstlisting}
£\ass{\smallbin{{⌊{\tt S}/8⌋}}{U\uplus\{{\tt P}+2{\sf w}↦{\tt S}-1{\sf w}\}}}£
£\ass{∃i,x．{\tt S} = 8i  *  0≤i<32  *  x = {\tt smallbin}+2i{\sf w}{}\\{}
*  \bin{{\smallsize i}}{x}{U\uplus\{{\tt P}+2{\sf w}↦{\tt S}-1{\sf w}\}} {}\\{}
*  {\tt smallmap}_{[i]}=(U\uplus\{{\tt P}+2{\sf w}↦{\tt S}-1{\sf w}\}≠\{\})}£
£\ass{∃i,x,y．{\tt S} = 8i  *  0≤i<32  *  x = {\tt smallbin}+2i{\sf w}{}\\{}
*  \fd{x}{y}  *  \bk{y}{x}  *  \bnode[*]{{\smallsize i}}{y}{x}{U\uplus\{{\tt P}+2{\sf w}↦{\tt S}-1{\sf w}\}} {}\\{}
*  {\tt smallmap}_{[i]}=(U\uplus\{{\tt P}+2{\sf w}↦{\tt S}-1{\sf w}\}≠\{\})}£
£\ass{∃i,x,y,F,U_1,U_2．{\tt S} = 8i  *  0≤i<32  *  x = {\tt smallbin}+2i{\sf w}{}\\{}
*  \fd{x}{y}  *  \bk{y}{x}  *  U=U_1\uplus U_2 {}\\{}
*  \bnode[*]{{\smallsize i}}{y}{{\tt P}}{U_1}  *  \fd{{\tt P}}{F}  *  \bk{F}{{\tt P}}  *  \frac12(\size{{\tt P}}{ {\tt S}})  *  \bnode[*]{{\smallsize i}}{F}{x}{U_2} {}\\{}
*  {\tt smallmap}_{[i]}=(U\uplus\{{\tt P}+2{\sf w}↦{\tt S}-1{\sf w}\}≠\{\})}£
£\ass{∃i,x,y,F,B,U_1,U_2．{\tt S} = 8i  *  0≤i<32  *  x = {\tt smallbin}+2i{\sf w}{}\\{}
*  U=U_1\uplus U_2 {}\\{}
*  ((y={\tt P}  *  B=x  *  U_1 = \{\}) {}\\{}
∨ (\fd{x}{y}  *  \bk{y}{x}  *  \bnode[*]{{\smallsize i}}{y}{B}{U_1\uplusminus\{B+2{\sf w}↦\underscore\}})) {}\\{}
*  \fd{B}{{\tt P}}  *  \bk{{\tt P}}{B}  *  \fd{{\tt P}}{F}  *  \frac12(\size{{\tt P}}{ {\tt S}})  *  \bk{F}{{\tt P}}  *  \bnode[*]{{\smallsize i}}{F}{x}{U_2} {}\\{}
*  {\tt smallmap}_{[i]}=(U\uplus\{{\tt P}+2{\sf w}↦{\tt S}-1{\sf w}\}≠\{\})}£
mchunkptr F = P->fd;
mchunkptr B = P->bk;
bindex_t I = small_index(S);
£\ass{∃x,y,U_1,U_2．{\tt S} = 8{\tt I}  *  0≤{\tt I}<32  *  x = {\tt smallbin}+2{\tt I}{\sf w}{}\\{}
*  U=U_1\uplus U_2 {}\\{}
*  ((y={\tt P}  *  {\tt B}=x  *  U_1 = \{\}) {}\\{}
∨ (\fd{x}{y}  *  \bk{y}{x}  *  \bnode[*]{{\smallsize {\tt I}}}{y}{{\tt B}}{U_1\uplusminus\{{\tt B}+2{\sf w}↦\underscore\}})) {}\\{}
*  \fd{{\tt B}}{{\tt P}}  *  \bk{{\tt P}}{{\tt B}}  *  \fd{{\tt P}}{{\tt F}}  *  \frac12(\size{{\tt P}}{ {\tt S}})  *  \bk{{\tt F}}{{\tt P}}  *  \bnode[*]{{\smallsize {\tt I}}}{{\tt F}}{x}{U_2} {}\\{}
*  {\tt smallmap}_{[{\tt I}]}=(U\uplus\{{\tt P}+2{\sf w}↦{\tt S}-1{\sf w}\}≠\{\})}£
//assert(P != B);
//assert(P != F);
//assert(chunksize(P) == small_index2size(I));
if (F == B)
  £\ass{∃x．{\tt S} = 8{\tt I}  *  0≤{\tt I}<32  *  x = {\tt smallbin}+2{\tt I}{\sf w}{}\\{}
*  U=\{\} *  {\tt F}={\tt B}=x {}\\{}
*  \fd{{\tt B}}{{\tt P}}  *  \bk{{\tt P}}{{\tt B}}  *  \fd{{\tt P}}{{\tt F}}  *  \bk{{\tt F}}{{\tt P}}  *  \frac12(\size{{\tt P}}{ {\tt S}}) {}\\{}
*  {\tt smallmap}_{[{\tt I}]}=(U\uplus\{{\tt P}+2{\sf w}↦{\tt S}-1{\sf w}\}≠\{\})}£
  clear_smallmap(M, I);
  £\ass{∃x．{\tt S} = 8{\tt I}  *  0≤{\tt I}<32  *  x = {\tt smallbin}+2{\tt I}{\sf w}{}\\{}
*  U=\{\}  *  \fd{x}{\underscore}  *  \bk{x}{\underscore}  *  {\tt smallmap}_{[{\tt I}]}=(U≠\{\}) {}\\{}
*  \fd{{\tt P}}{\underscore}  *  \bk{{\tt P}}{\underscore}  *  \frac12(\size{{\tt P}}{ {\tt S}})}£
else //if (RTCHECK((F == smallbin_at(M,I) || ok_address(M, F)) &&
     //            (B == smallbin_at(M,I) || ok_address(M, B)))) {
  F->bk = B;
  B->fd = F;
  £\ass{∃x,U_1,U_2．{\tt S} = 8{\tt I}  *  0≤{\tt I}<32  *  x = {\tt smallbin}+2{\tt I}{\sf w}{}\\{}
*  U=U_1\uplus U_2  *  U≠\{\} {}\\{}
*  ({\tt B}=x  *  U_1 = \{\}) {}\\{}
∨ (∃y．\fd{x}{y}  *  \bk{y}{x}  *  \bnode[*]{{\smallsize {\tt I}}}{y}{{\tt B}}{U_1\uplusminus\{{\tt B}+2{\sf w}↦\underscore\}}) {}\\{}
*  \fd{{\tt B}}{{\tt F}}  *  \bk{{\tt P}}{{\tt B}}  *  \fd{{\tt P}}{{\tt F}}  *  \frac12(\size{{\tt P}}{ {\tt S}})  *  \bk{{\tt F}}{{\tt B}}  *  \bnode[*]{{\smallsize {\tt I}}}{{\tt F}}{x}{U_2} {}\\{}
*  {\tt smallmap}_{[{\tt I}]}=(U\uplus\{{\tt P}+2{\sf w}↦{\tt S}-1{\sf w}\}≠\{\})}£
  £\ass{∃x,y,U_1,U_2． {\tt S} = 8{\tt I}  *  0≤{\tt I}<32  *  x = {\tt smallbin}+2{\tt I}{\sf w}{}\\{}
*  U=U_1\uplus U_2   *  U≠\{\}  *  \fd{x}{y}  *  \bk{y}{x} {}\\{}
*  \bnode[*]{{\smallsize {\tt I}}}{y}{{\tt F}}{U_1} {}\\{}
*  \fd{{\tt P}}{\underscore}  *  \bk{{\tt P}}{\underscore}  *  \frac12(\size{{\tt P}}{ {\tt S}}) *  \bnode[*]{{\smallsize {\tt I}}}{{\tt F}}{x}{U_2} {}\\{}
*  {\tt smallmap}_{[{\tt I}]}=(U\uplus\{{\tt P}+2{\sf w}↦{\tt S}-1{\sf w}\}≠\{\})}£
}
// else {
//   CORRUPTION_ERROR_ACTION(M);
// }
£\ass{{\tt S} = 8{\tt I}  *  0≤{\tt I}<32{}\\{}
*  \bin{{\smallsize {\tt I}}}{{\tt smallbin}+2{\tt I}{\sf w}}{U}  *  {\tt smallmap}_{[{\tt I}]}=(U≠\{\}) {}\\{}
*  \frac12(\size{{\tt P}}{ {\tt S}})  *  \fd{{\tt P}}{\underscore}  *  \bk{{\tt P}}{\underscore}
}£
£\ass{\frac12(\size{{\tt P}}{ {\tt S}})  *  \fd{{\tt P}}{\underscore}  *  \bk{{\tt P}}{\underscore}  *  \smallbin{{⌊{\tt S}/8⌋}}{U} }£

\end{lstlisting}

\section{{\tt unlink\_first\_small\_chunk}}

Specification:
\begin{lstlisting}
£\ass{∃F．{\tt B}={\tt smallbin}+2{\tt I}{\sf w}  *  0≤{\tt I}<32 {}\\{}
*  \fd{\tt B}{\tt P}  *  \bk{\tt P}{\tt B}  *  \frac12(\size{{\tt P}}{8{\tt I}})  *  \fd{\tt P}{F}  *  \bk{F}{\tt P} {}\\{}
*  \bnode[*]{{\smallsize {\tt I}}}{F}{\tt B}{U}  *  {\tt smallmap}_{[{\tt I}]}=1}£
unlink_first_small_chunk(M, B, P, I) //mods={}
£\ass{\frac12(\size{{\tt P}}{8{\tt I}})  *  \fd{{\tt P}}{\underscore}  *  \bk{{\tt P}}{\underscore}  *  \smallbin{{\tt I}}{U}}£
£\ £
\end{lstlisting}

\noindent Verification:
\begin{lstlisting}
£\ass{∃F． {\tt B}={\tt smallbin}+2{\tt I}{\sf w}  *  0≤{\tt I}<32 {}\\{}
*  \fd{\tt B}{\tt P}  *  \bk{\tt P}{\tt B}  *  \frac12(\size{{\tt P}}{8{\tt I}})  *  \fd{\tt P}{F}  *  \bk{F}{\tt P} {}\\{}
*  \bnode[*]{{\smallsize {\tt I}}}{F}{\tt B}{U}  *  {\tt smallmap}_{[{\tt I}]}=1}£
mchunkptr F = P->fd;
//assert(P != B);
//assert(P != F);
//assert(chunksize(P) == small_index2size(I));
£\ass{{\tt B}={\tt smallbin}+2{\tt I}{\sf w}  *  0≤{\tt I}<32 {}\\{}
*  \fd{\tt B}{\tt P}  *   \bk{\tt P}{\tt B}  *  \frac12(\size{{\tt P}}{8{\tt I}})  *  \fd{\tt P}{{\tt F}}  *  \bk{{\tt F}}{\tt P} {}\\{}
*  \bnode[*]{{\smallsize {\tt I}}}{{\tt F}}{\tt B}{U}  *  {\tt smallmap}_{[{\tt I}]}=1}£
if (B == F)
  clear_smallmap(M, I);
  £\ass{{\tt B}={\tt smallbin}+2{\tt I}{\sf w}  *  0≤{\tt I}<32 {}\\{}
*  \fd{\tt B}{\underscore}  *  \bk{{\tt B}}{\underscore}  *  U=\{\} {}\\{}
*  {\tt smallmap}_{[{\tt I}]}=(U≠\{\})  *  \frac12(\size{{\tt P}}{8{\tt I}})  *  \fd{\tt P}{\underscore}  *  \bk{\tt P}{\underscore}}£
else //if (RTCHECK(ok_address(M, F))) {
  £\ass{{\tt B}={\tt smallbin}+2{\tt I}{\sf w}  *  0≤{\tt I}<32 {}\\{}
*  \fd{\tt B}{\tt P}  *  \bk{\tt P}{\tt B}  *  \frac12(\size{{\tt P}}{8{\tt I}})  *   \fd{\tt P}{{\tt F}}  *  \bk{{\tt F}}{\tt P} {}\\{}
*  \bnode[*]{{\smallsize {\tt I}}}{{\tt F}}{\tt B}{U}  *  {\tt smallmap}_{[{\tt I}]}=(U≠\{\})}£
  B->fd = F;
  F->bk = B;
  £\ass{{\tt B}={\tt smallbin}+2{\tt I}{\sf w} {}\\{}
*  0≤{\tt I}<32  *  \fd{\tt B}{\tt F}  *  \bk{{\tt F}}{\tt B} {}\\{}
*  \bnode[*]{{\smallsize {\tt I}}}{{\tt F}}{\tt B}{U}  *  {\tt smallmap}_{[{\tt I}]}=(U≠\{\}) {}\\{} 
*  \frac12(\size{{\tt P}}{8{\tt I}})  *  \fd{\tt P}{\underscore}  *  \bk{\tt P}{\underscore}}£
}
// else {
//   CORRUPTION_ERROR_ACTION(M);
// }
£\ass{0≤{\tt I}<32  *  \bin{{\smallsize {\tt I}}}{{\tt smallbin}+2{\tt I}{\sf w}}{U} {}\\{}
*  {\tt smallmap}_{[{\tt I}]}=(U≠\{\})  *  \frac12(\size{{\tt P}}{8{\tt I}})  *   \fd{\tt P}{\underscore}  *  \bk{\tt P}{\underscore}}£
£\ass{\frac12(\size{{\tt P}}{8{\tt I}})  *   \fd{\tt P}{\underscore}  *  \bk{\tt P}{\underscore}  *  \smallbin{\tt I}{U}}£
\end{lstlisting}

\chapter{{\tt dlmalloc}}

Specification:
\begin{lstlisting}
£\ass{\state A}£
dlmalloc(bytes)
£\ass{∃n．n{\sf w} = \ceil[{\sf w}]{{\tt bytes}}  *  \state{A\uplus \{{\tt ret}↦ n{\sf w}\}} {}\\{} 
*  \iterstar[n]{i=0}．{\tt ret}+i{\sf w}↦\underscore  *  \frac12(\size{{\tt ret}-2{\sf w}}{\underscore})}£
\end{lstlisting}

\noindent Verification:


\setcounter{lstnumber}{0}
\begin{lstlisting}
£\ass{\state A}£
void* dlmalloc(size_t bytes) {
#if USE_LOCKS
  ensure_initialization(); /* initialize in sys_alloc if not using locks */
#endif
  if (!PREACTION(gm)) {
    void* mem;
    size_t nb;
    if (bytes <= MAX_SMALL_REQUEST) {
      £\ass{\state{A}  *  {\tt bytes} ≤ 244}£
\end{lstlisting}

\subsection*{Allocating small chunks}\label{sect:allocating_small_chunks}
\begin{lstlisting}
      bindex_t idx;
      binmap_t smallbits;
      nb = (bytes < MIN_REQUEST)? MIN_CHUNK_SIZE : pad_request(bytes);    
      idx = small_index(nb);
      smallbits = gm->smallmap >> idx;
      £\ass{∃\{U_i\mid i∈[0,63)\},n．\arena{A_{\sf a} \uplus (\biguplus_{i=0}^{64}．U_i)_{\sf u}}  *  \texttt{least\_addr}=5{\sf w} {}\\{}
*  n{\sf w} = \ceil[{\sf w}]{{\tt bytes}}  *  {\tt nb} = \max\{16,\ceil[8]{{\tt bytes}+4}\}  *  8{\tt idx}≥(n+1){\sf w} {}\\{}
*  2≤{\tt idx}<32  *  {\tt smallbits} = \floor{{\tt smallmap} / 2^{\tt idx}} {}\\{}
*  \iterstar[32]{i=0}．\smallbin{i}{U_i}  *  \iterstar[32]{i=0}．\treebin{i}{U_{i+32}}}£
      if ((smallbits & 0x3U) != 0) { /* Remainderless fit to a smallbin. */
        £\ass{∃\{U_i\mid i∈[0,63)\},n．\arena{A_{\sf a} \uplus (\biguplus_{i=0}^{64}．U_i)_{\sf u}}  *  \texttt{least\_addr}=5{\sf w} {}\\{}
*  n{\sf w} = \ceil[{\sf w}]{{\tt bytes}}  *  8{\tt idx}≥(n+1){\sf w} {}\\{}
*  2≤{\tt idx}<32  *  {\tt smallbits} = \floor{{\tt smallmap} / 2^{\tt idx}} {}\\{}
*  \iterstar[32]{i=0}．\smallbin{i}{U_i}  *  \iterstar[32]{i=0}．\treebin{i}{U_{i+32}} {}\\{}
*  {\tt smallbits}_{[1,0]} ≠ 00}£
\end{lstlisting}

\subsubsection*{`Remainderless' fit to a smallbin}\label{sect:remainderless_fit_to_a_smallbin}
\begin{lstlisting}
        mchunkptr b, p;
        idx += ~smallbits & 1;       /* Uses next bin if idx empty */
        £\ass{∃\{U_i\mid i∈[0,63)\},n．\arena{A_{\sf a} \uplus (\biguplus_{i=0}^{64}．U_i)_{\sf u}}  *  \texttt{least\_addr}=5{\sf w} {}\\{}
*  n{\sf w} = \ceil[{\sf w}]{{\tt bytes}}  *  8{\tt idx}≥(n+1){\sf w}  *  2≤{\tt idx}<32  *  {\tt smallmap}_{[{\tt idx}]} = 1 {}\\{}
*  \iterstar[32]{i=0}．\smallbin{i}{U_i}  *  \iterstar[32]{i=0}．\treebin{i}{U_{i+32}}}£     
        b = smallbin_at(gm, idx);
        £\ass{∃\{U_i\mid i∈[0,63)\},n．\arena{A_{\sf a} \uplus (\biguplus_{i=0}^{64}．U_i)_{\sf u}}  *  \texttt{least\_addr}=5{\sf w} {}\\{}
*  n{\sf w} = \ceil[{\sf w}]{{\tt bytes}}  *  8{\tt idx}≥(n+1){\sf w}  *  2≤{\tt idx}<32  *  {\tt smallmap}_{[{\tt idx}]} = 1 {}\\{}
*  {\tt b}={\tt smallbins}+8{\tt idx}  *  \bin{\smallsize{\tt idx}}{\tt b}{U_{{\tt idx}}}  *  U_{{\tt idx}} ≠ \{\} {}\\{}
*  \iterstar{i∈[0..32)-{\tt idx}}．\smallbin{i}{U_i}  *  \iterstar[32]{i=0}．\treebin{i}{U_{i+32}}}£ 
        // rename U_idx to U_idx++[p+2w->8idx-1w]
        £\ass{∃\{U_i\mid i∈[0,63)\},p,n．\arena{A_{\sf a} \uplus (\biguplus_{i=0}^{64}．U_i)_{\sf u} \uplus \{p+2{\sf w}↦_{\sf u}8{\tt idx}-1{\sf w}\}} {}\\{}
*  \texttt{least\_addr}=5{\sf w}  * n{\sf w} = \ceil[{\sf w}]{{\tt bytes}}  *  8{\tt idx}≥(n+1){\sf w}  *  2≤{\tt idx}<32 {}\\{}
*  {\tt smallmap}_{[{\tt idx}]} = 1  *  {\tt b}={\tt smallbins}+8{\tt idx} {}\\{}
*  \fd{\tt b}{p}  *  \bk{p}{\tt b}  *  \bnode[*]{\smallsize{\tt idx}}{p}{\tt b}{U_{{\tt idx}} \uplus \{p+2{\sf w}↦8{\tt idx}-1{\sf w}\}} {}\\{}
*  \iterstar{i∈[0..32)-{\tt idx}}．\smallbin{i}{U_i}  *  \iterstar[32]{i=0}．\treebin{i}{U_{i+32}}}£ 
        p = b->fd;
        £\ass{∃\{U_i\mid i∈[0,63)\},n,F．\arena{A_{\sf a} \uplus (\biguplus_{i=0}^{64}．U_i)_{\sf u}\uplus \{{\tt p}+2{\sf w}↦_{\sf u} 8{\tt idx}-1{\sf w}\}} {}\\{} 
*  \texttt{least\_addr}=5{\sf w}  * n{\sf w} = \ceil[{\sf w}]{{\tt bytes}}  *  8{\tt idx}≥(n+1){\sf w}  *  2≤{\tt idx}<32 {}\\{}
*  {\tt smallmap}_{[{\tt idx}]} = 1  *  {\tt b}={\tt smallbins}+8{\tt idx} {}\\{}
*  \fd{\tt b}{\tt p}  *  \bk{\tt p}{\tt b}  *  \frac12(\size{\tt p}{8{\tt idx}})  *  \fd{\tt p}{F}  *  \bk{F}{\tt p}  *  \bnode[*]{\smallsize{\tt idx}}{F}{\tt b}{U_{{\tt idx}}} {}\\{}
*  \iterstar{i∈[0..32)-{\tt idx}}．\smallbin{i}{U_i}  *  \iterstar[32]{i=0}．\treebin{i}{U_{i+32}}}£ 
        //assert(chunksize(p) == small_index2size(idx));
        unlink_first_small_chunk(gm, b, p, idx);
        £\ass{∃\{U_i\mid i∈[0,63)\},n．\arena{A_{\sf a} \uplus (\biguplus_{i=0}^{64}．U_i)_{\sf u}\uplus \{{\tt p}+2{\sf w}↦_{\sf u} 8{\tt idx}-1{\sf w}\}} {}\\{}
*  \texttt{least\_addr}=5{\sf w}  * n{\sf w} = \ceil[{\sf w}]{{\tt bytes}}  *  8{\tt idx}≥(n+1){\sf w}  *  2≤{\tt idx}<32 {}\\{}
*  \frac12(\size{\tt p}{8{\tt idx}})  *  \fd{\tt p}{\underscore}   *  \bk{\tt p}{\underscore}  *  \iterstar[32]{i=0}．\smallbin{i}{U_i}  *  \iterstar[32]{i=0}．\treebin{i}{U_{i+32}}}£ 
        £\ass{∃\{U_i\mid i∈[0,63)\},B_1,B_2,n．\coallesced{A_{\sf a} \uplus (\biguplus_{i=0}^{64}．U_i)_{\sf u}\uplus \{{\tt p}+2{\sf w}↦_{\sf u} 8{\tt idx}-1{\sf w}\}} {}\\{} *  \prevfoot{\tt start}{\underscore}  *  \pinuse{\tt start}{1}  *  \ublock{{\tt top}}{{\tt top}+{\tt topsize}}{\underscore} {}\\{}
*  \block[*]{\tt start}{\tt p}{B_1}  *  \ublock{\tt p}{{\tt p}+8{\tt idx}}{\{{\tt p}+2{\sf w}↦_{\sf u} 8{\tt idx}-1{\sf w}\}} {}\\{}
*  \block[*]{{\tt p}+8{\tt idx}}{\tt top}{B_2}  *  B_1 \uplus B_2 = A_{\sf a} \uplus (\biguplus_{i=0}^{64}．U_i)_{\sf u} {}\\{}
*  \texttt{least\_addr}=5{\sf w}  * n{\sf w} = \ceil[{\sf w}]{{\tt bytes}}  *  8{\tt idx}≥(n+1){\sf w}  *  2≤{\tt idx}<32 {}\\{}
*  \frac12(\size{\tt p}{8{\tt idx}})  *  \fd{\tt p}{\underscore}   *  \bk{\tt p}{\underscore}  *  \iterstar[32]{i=0}．\smallbin{i}{U_i}  *  \iterstar[32]{i=0}．\treebin{i}{U_{i+32}}}£ 
        £\ass{∃\{U_i\mid i∈[0,63)\},B_1,B_2,n．\coallesced{A_{\sf a} \uplus (\biguplus_{i=0}^{64}．U_i)_{\sf u}\uplus \{{\tt p}+2{\sf w}↦_{\sf u} 8{\tt idx}-1{\sf w}\}} {}\\{} *  \prevfoot{\tt start}{\underscore}  *  \pinuse{\tt start}{1}  *  \ublock{{\tt top}}{{\tt top}+{\tt topsize}}{\underscore} {}\\{}
*  \block[*]{\tt start}{\tt p}{B_1}  *  \block[*]{{\tt p}+8{\tt idx}}{\tt top}{B_2} {}\\{}
*  B_1 \uplus B_2 = A_{\sf a} \uplus (\biguplus_{i=0}^{64}．U_i)_{\sf u} {}\\{}
*  \frac12(\size{\tt p}{8{\tt idx}})  *  \pinuse{{\tt p}+8{\tt idx}}{0}  *  \cinuse{{\tt p}}{0}  *  \prevfoot{{\tt p}+8{\tt idx}}{8{\tt idx}}  *  \iterstar[2{\tt idx}]{i=4}．{\tt p} + i{\sf w}↦\underscore {}\\{}
*  \texttt{least\_addr}=5{\sf w}  * n{\sf w} = \ceil[{\sf w}]{{\tt bytes}}  *  8{\tt idx}≥(n+1){\sf w}  *  2≤{\tt idx}<32 {}\\{}
*  \frac12(\size{\tt p}{8{\tt idx}})  *  \fd{\tt p}{\underscore}   *  \bk{\tt p}{\underscore}  *  \iterstar[32]{i=0}．\smallbin{i}{U_i}  *  \iterstar[32]{i=0}．\treebin{i}{U_{i+32}}}£
        // use Lemma £\color{DarkGreen}{\tt \ref{lem:coallesced}}£ 
        £\ass{∃\{U_i\mid i∈[0,63)\},B_1,B_2,n．\coallesced{A_{\sf a} \uplus (\biguplus_{i=0}^{64}．U_i)_{\sf u}\uplus \{{\tt p}+2{\sf w}↦_{\sf u} 8{\tt idx}-1{\sf w}\}} {}\\{} *  \prevfoot{\tt start}{\underscore}  *  \pinuse{\tt start}{1}  *  \ublock{{\tt top}}{{\tt top}+{\tt topsize}}{\underscore} {}\\{}
*  (({\tt start}={\tt p}  *  B_1=\{\}){}\\{}
∨(∃q,m．\block[*]{\tt start}{q}{B_1\uplusminus\{q+2{\sf w}↦m\}}  *  \ablock{q}{\tt p}{q+2{\sf w}↦m{\sf w}})) {}\\{}
*  \block[*]{{\tt p}+8{\tt idx}}{\tt top}{B_2}  *  B_1 \uplus B_2 = A_{\sf a} \uplus (\biguplus_{i=0}^{64}．U_i)_{\sf u} {}\\{}
*  \frac12(\size{\tt p}{8{\tt idx}})  *  \pinuse{{\tt p}+8{\tt idx}}{0}  *  \cinuse{{\tt p}}{0}  *  \prevfoot{{\tt p}+8{\tt idx}}{8{\tt idx}}  *  \iterstar[2{\tt idx}]{i=4}．{\tt p} + i{\sf w}↦\underscore {}\\{}
*  \texttt{least\_addr}=5{\sf w}  * n{\sf w} = \ceil[{\sf w}]{{\tt bytes}}  *  8{\tt idx}≥(n+1){\sf w}  *  2≤{\tt idx}<32 {}\\{}
*  \frac12(\size{\tt p}{8{\tt idx}})  *  \fd{\tt p}{\underscore}   *  \bk{\tt p}{\underscore}  *  \iterstar[32]{i=0}．\smallbin{i}{U_i}  *  \iterstar[32]{i=0}．\treebin{i}{U_{i+32}}}£ 
        £\ass{∃\{U_i\mid i∈[0,63)\},B_1,B_2,n．\coallesced{A_{\sf a} \uplus (\biguplus_{i=0}^{64}．U_i)_{\sf u}\uplus \{{\tt p}+2{\sf w}↦_{\sf u} 8{\tt idx}-1{\sf w}\}} {}\\{} *  \prevfoot{\tt start}{\underscore}  *  \pinuse{\tt start}{1}  *  \ublock{{\tt top}}{{\tt top}+{\tt topsize}}{\underscore} {}\\{}
*  (({\tt start}={\tt p}  *  B_1=\{\}){}\\{}
∨(∃q,m．\block[*]{\tt start}{q}{B_1\uplusminus\{q+2{\sf w}↦m\}} {}\\{}
*  (m+1){\sf w} ≤ {\tt p}-q  *  \frac12(\size{q}{{\tt p}-q})  *  \pinuse{\tt p}{1} {}\\{}
*  \cinuse{q}{1}  *  {\tt p}-q ≥ 4{\sf w}  *  \iterstar[({\tt p}-q)/{\sf w}+1]{i=m+2}．q+i{\sf w}↦\underscore)) {}\\{}
*  \block[*]{{\tt p}+8{\tt idx}}{\tt top}{B_2}  *  B_1 \uplus B_2 = A_{\sf a} \uplus (\biguplus_{i=0}^{64}．U_i)_{\sf u} {}\\{}
*  \frac12(\size{\tt p}{8{\tt idx}})  *  \pinuse{{\tt p}+8{\tt idx}}{0}  *  \cinuse{{\tt p}}{0}  *  \prevfoot{{\tt p}+8{\tt idx}}{8{\tt idx}}  *  \iterstar[2{\tt idx}]{i=4}．{\tt p} + i{\sf w}↦\underscore {}\\{}
*  \texttt{least\_addr}=5{\sf w}  * n{\sf w} = \ceil[{\sf w}]{{\tt bytes}}  *  8{\tt idx}≥(n+1){\sf w}  *  2≤{\tt idx}<32 {}\\{}
*  \frac12(\size{\tt p}{8{\tt idx}})  *  \fd{\tt p}{\underscore}   *  \bk{\tt p}{\underscore}  *  \iterstar[32]{i=0}．\smallbin{i}{U_i}  *  \iterstar[32]{i=0}．\treebin{i}{U_{i+32}}}£ 
        £\ass{∃\{U_i\mid i∈[0,63)\},B_1,B_2,n．\coallesced{A_{\sf a} \uplus (\biguplus_{i=0}^{64}．U_i)_{\sf u}\uplus \{{\tt p}+2{\sf w}↦_{\sf u} 8{\tt idx}-1{\sf w}\}} {}\\{} *  \prevfoot{\tt start}{\underscore}  *  \ublock{{\tt top}}{{\tt top}+{\tt topsize}}{\underscore} {}\\{}
*  (({\tt start}={\tt p}  *  B_1=\{\}){}\\{}
∨(∃q,m．\pinuse{\tt start}{1}  *  \block[*]{\tt start}{q}{B_1\uplusminus\{q+2{\sf w}↦m\}} {}\\{}
*  (m+1){\sf w} ≤ {\tt p}-q  *  \frac12(\size{q}{{\tt p}-q}) {}\\{}
*  \cinuse{q}{1}  *  {\tt p}-q ≥ 4{\sf w}  *  \iterstar[({\tt p}-q)/{\sf w}+1]{i=m+2}．q+i{\sf w}↦\underscore)) {}\\{}
*  \block[*]{{\tt p}+8{\tt idx}}{\tt top}{B_2}  *  B_1 \uplus B_2 = A_{\sf a} \uplus (\biguplus_{i=0}^{64}．U_i)_{\sf u} {}\\{}
*  \frac12(\size{\tt p}{8{\tt idx}})  *  \pinuse{{\tt p}+8{\tt idx}}{0}  *  \pinuse{\tt p}{1}  *  \cinuse{{\tt p}}{0}  *  \prevfoot{{\tt p}+8{\tt idx}}{8{\tt idx}}  *  \iterstar[2{\tt idx}]{i=4}．{\tt p} + i{\sf w}↦\underscore {}\\{}
*  \texttt{least\_addr}=5{\sf w}  * n{\sf w} = \ceil[{\sf w}]{{\tt bytes}}  *  8{\tt idx}≥(n+1){\sf w}  *  2≤{\tt idx}<32 {}\\{}
*  \frac12(\size{\tt p}{8{\tt idx}})  *  \fd{\tt p}{\underscore}   *  \bk{\tt p}{\underscore}  *  \iterstar[32]{i=0}．\smallbin{i}{U_i}  *  \iterstar[32]{i=0}．\treebin{i}{U_{i+32}}}£ 
        set_inuse_and_pinuse(gm, p, small_index2size(idx));
        £\ass{∃\{U_i\mid i∈[0,63)\},B_1,B_2,n．\coallesced{A_{\sf a} \uplus (\biguplus_{i=0}^{64}．U_i)_{\sf u}\uplus \{{\tt p}+2{\sf w}↦_{\sf u} 8{\tt idx}-1{\sf w}\}} {}\\{} *  \prevfoot{\tt start}{\underscore}  *  \ublock{{\tt top}}{{\tt top}+{\tt topsize}}{\underscore} {}\\{}
*  (({\tt start}={\tt p}  *  B_1=\{\}){}\\{}
∨(∃q,m．\pinuse{\tt start}{1}  *  \block[*]{\tt start}{q}{B_1\uplusminus\{q+2{\sf w}↦m\}} {}\\{}
*  (m+1){\sf w} ≤ {\tt p}-q  *  \frac12(\size{q}{{\tt p}-q}) {}\\{}
*  \cinuse{q}{1}  *  {\tt p}-q ≥ 4{\sf w}  *  \iterstar[({\tt p}-q)/{\sf w}+1]{i=m+2}．q+i{\sf w}↦\underscore)) {}\\{}
*  \block[*]{{\tt p}+8{\tt idx}}{\tt top}{B_2}  *  B_1 \uplus B_2 = A_{\sf a} \uplus (\biguplus_{i=0}^{64}．U_i)_{\sf u} {}\\{}
*  \frac12(\size{\tt p}{8{\tt idx}})  *  \pinuse{{\tt p}+8{\tt idx}}{1}  *  \pinuse{\tt p}{1}  *  \cinuse{{\tt p}}{1}  *  \prevfoot{{\tt p}+8{\tt idx}}{8{\tt idx}}  *  \iterstar[2{\tt idx}]{i=4}．{\tt p} + i{\sf w}↦\underscore {}\\{}
*  \texttt{least\_addr}=5{\sf w}  * n{\sf w} = \ceil[{\sf w}]{{\tt bytes}}  *  8{\tt idx}≥(n+1){\sf w}  *  2≤{\tt idx}<32 {}\\{}
*  \frac12(\size{\tt p}{8{\tt idx}})  *  \fd{\tt p}{\underscore}   *  \bk{\tt p}{\underscore}  *  \iterstar[32]{i=0}．\smallbin{i}{U_i}  *  \iterstar[32]{i=0}．\treebin{i}{U_{i+32}}}£ 
        £\ass{∃\{U_i\mid i∈[0,63)\},B_1,B_2,n．\coallesced{A_{\sf a} \uplus (\biguplus_{i=0}^{64}．U_i)_{\sf u}\uplus \{{\tt p}+2{\sf w}↦_{\sf u} 8{\tt idx}-1{\sf w}\}} {}\\{} *  \prevfoot{\tt start}{\underscore}  *  \pinuse{\tt start}{1}  *  \ublock{{\tt top}}{{\tt top}+{\tt topsize}}{\underscore} {}\\{}
*  (({\tt start}={\tt p}  *  B_1=\{\}){}\\{}
∨(∃q,m．\block[*]{\tt start}{q}{B_1\uplusminus\{q+2{\sf w}↦m\}} {}\\{}
*  (m+1){\sf w} ≤ {\tt p}-q  *  \frac12(\size{q}{{\tt p}-q}) {}\\{}
*  \pinuse{\tt p}{1}  *  \cinuse{q}{1}  *  {\tt p}-q ≥ 4{\sf w}  *  \iterstar[({\tt p}-q)/{\sf w}+1]{i=m+2}．q+i{\sf w}↦\underscore)) {}\\{}
*  \block[*]{{\tt p}+8{\tt idx}}{\tt top}{B_2}  *  B_1 \uplus B_2 = A_{\sf a} \uplus (\biguplus_{i=0}^{64}．U_i)_{\sf u} {}\\{}
*  \frac12(\size{\tt p}{8{\tt idx}})  *  \pinuse{{\tt p}+8{\tt idx}}{1}  *  \cinuse{{\tt p}}{1}  *  \prevfoot{{\tt p}+8{\tt idx}}{8{\tt idx}}  *  \iterstar[2{\tt idx}]{i=4}．{\tt p} + i{\sf w}↦\underscore {}\\{}
*  \texttt{least\_addr}=5{\sf w}  * n{\sf w} = \ceil[{\sf w}]{{\tt bytes}}  *  8{\tt idx}≥(n+1){\sf w}  *  2≤{\tt idx}<32 {}\\{}
*  \frac12(\size{\tt p}{8{\tt idx}})  *  \fd{\tt p}{\underscore}   *  \bk{\tt p}{\underscore}  *  \iterstar[32]{i=0}．\smallbin{i}{U_i}  *  \iterstar[32]{i=0}．\treebin{i}{U_{i+32}}}£ 
        £\ass{∃\{U_i\mid i∈[0,63)\},B_1,B_2,n．\coallesced{A_{\sf a} \uplus (\biguplus_{i=0}^{64}．U_i)_{\sf u}\uplus \{{\tt p}+2{\sf w}↦_{\sf u} 8{\tt idx}-1{\sf w}\}} {}\\{} *  \prevfoot{\tt start}{\underscore}  *  \pinuse{\tt start}{1}  *  \ublock{{\tt top}}{{\tt top}+{\tt topsize}}{\underscore} {}\\{}
*  \block[*]{\tt start}{\tt p}{B_1}  *  \block[*]{{\tt p}+8{\tt idx}}{\tt top}{B_2} {}\\{}
*  B_1 \uplus B_2 = A_{\sf a} \uplus (\biguplus_{i=0}^{64}．U_i)_{\sf u} {}\\{}
*  \frac12(\size{\tt p}{8{\tt idx}})  *  \pinuse{{\tt p}+8{\tt idx}}{1}  *  \cinuse{{\tt p}}{1}  *  \prevfoot{{\tt p}+8{\tt idx}}{8{\tt idx}}  * \iterstar[2{\tt idx}]{i=4}．{\tt p} + i{\sf w}↦\underscore {}\\{}
*  \texttt{least\_addr}=5{\sf w}  * n{\sf w} = \ceil[{\sf w}]{{\tt bytes}}  *  8{\tt idx}≥(n+1){\sf w}  *  2≤{\tt idx}<32 {}\\{}
*  \frac12(\size{\tt p}{8{\tt idx}})  *  \fd{\tt p}{\underscore}   *  \bk{\tt p}{\underscore}  *  \iterstar[32]{i=0}．\smallbin{i}{U_i}  *  \iterstar[32]{i=0}．\treebin{i}{U_{i+32}}}£ 
        £\ass{∃\{U_i\mid i∈[0,63)\},B_1,B_2,n．\coallesced{A_{\sf a} \uplus (\biguplus_{i=0}^{64}．U_i)_{\sf u}\uplus \{{\tt p}+2{\sf w}↦_{\sf u} 8{\tt idx}-1{\sf w}\}} {}\\{} *  \prevfoot{\tt start}{\underscore}  *  \pinuse{\tt start}{1}  *  \ublock{{\tt top}}{{\tt top}+{\tt topsize}}{\underscore} {}\\{}
*  \block[*]{\tt start}{\tt p}{B_1}  *  \block[*]{{\tt p}+8{\tt idx}}{\tt top}{B_2} {}\\{}
*  B_1 \uplus B_2 = A_{\sf a} \uplus (\biguplus_{i=0}^{64}．U_i)_{\sf u} {}\\{}
*  \frac12(\size{\tt p}{8{\tt idx}})  *  \pinuse{{\tt p}+8{\tt idx}}{1}  *  \cinuse{{\tt p}}{1} {}\\{}
* \iterstar[n+2]{i=2}．{\tt p} + i{\sf w}↦\underscore  * \iterstar[2{\tt idx}+1]{i=n+2}．{\tt p} + i{\sf w}↦\underscore {}\\{}
*  \texttt{least\_addr}=5{\sf w}  * n{\sf w} = \ceil[{\sf w}]{{\tt bytes}} {}\\{}
*  \frac12(\size{\tt p}{8{\tt idx}})  * \iterstar[32]{i=0}．\smallbin{i}{U_i}  *  \iterstar[32]{i=0}．\treebin{i}{U_{i+32}}}£ 
        £\ass{∃\{U_i\mid i∈[0,63)\},B_1,B_2,n．\coallesced{A_{\sf a} \uplus (\biguplus_{i=0}^{64}．U_i)_{\sf u}\uplus \{{\tt p}+2{\sf w}↦_{\sf u} 8{\tt idx}-1{\sf w}\}} {}\\{} *  \prevfoot{\tt start}{\underscore}  *  \pinuse{\tt start}{1}  *  \ublock{{\tt top}}{{\tt top}+{\tt topsize}}{\underscore} {}\\{}
*  \block[*]{\tt start}{\tt p}{B_1}  *  \block[*]{{\tt p}+8{\tt idx}}{\tt top}{B_2} {}\\{}
*  B_1 \uplus B_2 = A_{\sf a} \uplus (\biguplus_{i=0}^{64}．U_i)_{\sf u} {}\\{}
*  \ablock{\tt p}{{\tt p}+8{\tt idx}}{\{{\tt p}+2{\sf w}↦_{\sf a} n{\sf w}\}}  * \iterstar[n+2]{i=2}．{\tt p} + i{\sf w}↦\underscore {}\\{}
*  \texttt{least\_addr}=5{\sf w}  * n{\sf w} = \ceil[{\sf w}]{{\tt bytes}} {}\\{}
*  \frac12(\size{\tt p}{8{\tt idx}})  *  \iterstar[32]{i=0}．\smallbin{i}{U_i}  *  \iterstar[32]{i=0}．\treebin{i}{U_{i+32}}}£ 
        £\ass{∃\{U_i\mid i∈[0,63)\}．\arena{A_{\sf a} \uplus (\biguplus_{i=0}^{64}．U_i)_{\sf u} \uplus \{{\tt p}+2{\sf w}↦_{\sf a} n{\sf w}\}} {}\\{} 
* \iterstar[n+2]{i=2}．{\tt p} + i{\sf w}↦\underscore {}\\{}
*  \texttt{least\_addr}=5{\sf w}  * n{\sf w} = \ceil[{\sf w}]{{\tt bytes}}  {}\\{}
*  \frac12(\size{\tt p}{\underscore})  *  \iterstar[32]{i=0}．\smallbin{i}{U_i}  *  \iterstar[32]{i=0}．\treebin{i}{U_{i+32}}}£ 
        £\ass{∃n．n{\sf w} = \ceil[{\sf w}]{{\tt bytes}}  *  \state{A\uplus \{{\tt p}+2{\sf w}↦ n{\sf w}\}} {}\\{} 
*  \iterstar[n]{i=0}．{\tt p}+2{\sf w}+i{\sf w}↦\underscore  *  \frac12(\size{\tt p}{\underscore})}£
        mem = chunk2mem(p);
        //check_malloced_chunk(gm, mem, nb);
        £\ass{∃n．n{\sf w} = \ceil[{\sf w}]{{\tt bytes}}  *  \state{A\uplus \{{\tt mem}↦ n{\sf w}\}} {}\\{} 
*  \iterstar[n]{i=0}．{\tt mem}+i{\sf w}↦\underscore  *  \frac12(\size{{\tt mem}-2{\sf w}}{\underscore})}£
        goto postaction;
      }
      else if (nb > gm->dvsize) {
        £\ass{∃\{U_i\mid i∈[0,63)\},n．\arena{A_{\sf a} \uplus (\biguplus_{i=0}^{64}．U_i)_{\sf u}}  *  \texttt{least\_addr}=5{\sf w} {}\\{}
*  n{\sf w} = \ceil[{\sf w}]{{\tt bytes}}  *  {\tt nb} = \max\{16,\ceil[8]{{\tt bytes}+4}\}  *  8{\tt idx}≥(n+1){\sf w} {}\\{}
*  2≤{\tt idx}<32  *  {\tt smallbits} = \floor{{\tt smallmap} / 2^{\tt idx}} {}\\{}
*  \iterstar[32]{i=0}．\smallbin{i}{U_i}  *  \iterstar[32]{i=0}．\treebin{i}{U_{i+32}}}£
        if (smallbits != 0) { /* Use chunk in next nonempty smallbin */
          £\ass{∃\{U_i\mid i∈[0,63)\},n．\arena{A_{\sf a} \uplus (\biguplus_{i=0}^{64}．U_i)_{\sf u}}  *  \texttt{least\_addr}=5{\sf w} {}\\{}
*  n{\sf w} = \ceil[{\sf w}]{{\tt bytes}}  *  {\tt nb} = \max\{16,\ceil[8]{{\tt bytes}+4}\}  *  8{\tt idx}≥(n+1){\sf w} {}\\{}
*  2≤{\tt idx}<32  *  {\tt smallbits} = \floor{{\tt smallmap} / 2^{\tt idx}}  *  {\tt smallmap}≥2^{\tt idx} {}\\{}
*  \iterstar[32]{i=0}．\smallbin{i}{U_i}  *  \iterstar[32]{i=0}．\treebin{i}{U_{i+32}}}£
\end{lstlisting}

\subsubsection*{`Remainderful' fit to a smallbin}\label{sect:remainderful_fit_to_a_smallbin}

\begin{lstlisting}
          mchunkptr b, p, r;
          size_t rsize;
          bindex_t i;
          binmap_t leftbits = (smallbits << idx) & left_bits(idx2bit(idx));
          binmap_t leastbit = least_bit(leftbits);
          compute_bit2idx(leastbit, i);
          £\ass{∃\{U_i\mid i∈[0,63)\},n．\arena{A_{\sf a} \uplus (\biguplus_{i=0}^{64}．U_i)_{\sf u}}  *  \texttt{least\_addr}=5{\sf w} {}\\{}
*  n{\sf w} = \ceil[{\sf w}]{{\tt bytes}}  *  {\tt nb} = \max\{16,\ceil[8]{{\tt bytes}+4}\}  *   8{\tt i}≥(n+1){\sf w} {}\\{}
*  2≤{\tt i}<32  *  {\tt smallmap}_{[{\tt i}]} = 1 {}\\{}
*  \iterstar[32]{i=0}．\smallbin{i}{U_i}  *  \iterstar[32]{i=0}．\treebin{i}{U_{i+32}}}£
          b = smallbin_at(gm, i);
          £\ass{∃\{U_i\mid i∈[0,63)\},n．\arena{A_{\sf a} \uplus (\biguplus_{i=0}^{64}．U_i)_{\sf u}}  *  \texttt{least\_addr}=5{\sf w} {}\\{}
*  n{\sf w} = \ceil[{\sf w}]{{\tt bytes}}  *  {\tt nb} = \max\{16,\ceil[8]{{\tt bytes}+4}\}  *  8{\tt i}≥(n+1){\sf w} {}\\{} *  2≤{\tt i}<32  *  {\tt smallmap}_{[{\tt i}]} = 1 {}\\{}
*  {\tt b}={\tt smallbins}+8{\tt i}  *  \bin{\smallsize{\tt i}}{\tt b}{U_{{\tt i}}}  *  U_{{\tt i}} ≠ \{\} {}\\{}
*  \iterstar{i∈[0..32)-{\tt i}}．\smallbin{i}{U_i}  *  \iterstar[32]{i=0}．\treebin{i}{U_{i+32}}}£
          // rename U_idx to U_idx++[p+2w->8i-1w]
          £\ass{∃\{U_i\mid i∈[0,63)\},p,n．\arena{A_{\sf a} \uplus (\biguplus_{i=0}^{64}．U_i)_{\sf u} \uplus \{p+2{\sf w}↦_{\sf u}8{\tt i}-1{\sf w}\}} {}\\{}
*  \texttt{least\_addr}=5{\sf w}  * n{\sf w} = \ceil[{\sf w}]{{\tt bytes}}  *  {\tt nb} = \max\{16,\ceil[8]{{\tt bytes}+4}\}  *  8{\tt i}≥(n+1){\sf w} {}\\{} *  2≤{\tt i}<32  *  {\tt smallmap}_{[{\tt i}]} = 1  *  {\tt b}={\tt smallbins}+8{\tt i} {}\\{}
*  \fd{\tt b}{p}  *  \bk{p}{\tt b}  *  \bnode[*]{\smallsize{\tt i}}{p}{\tt b}{U_{{\tt i}} \uplus \{p+2{\sf w}↦8{\tt i}-1{\sf w}\}} {}\\{}
*  \iterstar{i∈[0..32)-{\tt i}}．\smallbin{i}{U_i}  *  \iterstar[32]{i=0}．\treebin{i}{U_{i+32}}}£
          p = b->fd;
          £\ass{∃\{U_i\mid i∈[0,63)\},n,F．\arena{A_{\sf a} \uplus (\biguplus_{i=0}^{64}．U_i)_{\sf u}\uplus \{{\tt p}+2{\sf w}↦_{\sf u} 8{\tt i}-1{\sf w}\}} {}\\{} 
*  \texttt{least\_addr}=5{\sf w}  * n{\sf w} = \ceil[{\sf w}]{{\tt bytes}}   *  {\tt nb} = \max\{16,\ceil[8]{{\tt bytes}+4}\}  *  8{\tt i}≥(n+1){\sf w} {}\\{}  *  2≤{\tt i}<32  *  {\tt smallmap}_{[{\tt i}]} = 1  *  {\tt b}={\tt smallbins}+8{\tt i} {}\\{}
*  \fd{\tt b}{\tt p}  *  \bk{\tt p}{\tt b}  *  \frac12(\size{\tt p}{8{\tt i}})  *  \fd{\tt p}{F}  *  \bk{F}{\tt p}  *  \bnode[*]{\smallsize{\tt i}}{F}{\tt b}{U_{{\tt i}}} {}\\{}
*  \iterstar{i∈[0..32)-{\tt i}}．\smallbin{i}{U_i}  *  \iterstar[32]{i=0}．\treebin{i}{U_{i+32}}}£ 
          //assert(chunksize(p) == small_index2size(i));
          unlink_first_small_chunk(gm, b, p, i);
          £\ass{∃\{U_i\mid i∈[0,63)\},n．\arena{A_{\sf a} \uplus (\biguplus_{i=0}^{64}．U_i)_{\sf u}\uplus \{{\tt p}+2{\sf w}↦_{\sf u} 8{\tt i}-1{\sf w}\}} {}\\{}
*  \texttt{least\_addr}=5{\sf w}  * n{\sf w} = \ceil[{\sf w}]{{\tt bytes}}  *  {\tt nb} = \max\{16,\ceil[8]{{\tt bytes}+4}\}  *  8{\tt i}≥(n+1){\sf w} {}\\{} *  2≤{\tt i}<32  *  \frac12(\size{\tt p}{8{\tt i}})  *  \fd{\tt p}{\underscore}   *  \bk{\tt p}{\underscore}  *  \iterstar[32]{i=0}．\smallbin{i}{U_i}  *  \iterstar[32]{i=0}．\treebin{i}{U_{i+32}}}£
          //... as before ...
          £\ass{∃\{U_i\mid i∈[0,63)\},B_1,B_2,n．\coallesced{A_{\sf a} \uplus (\biguplus_{i=0}^{64}．U_i)_{\sf u}\uplus \{{\tt p}+2{\sf w}↦_{\sf u} 8{\tt i}-1{\sf w}\}} {}\\{} *  \prevfoot{\tt start}{\underscore}  *  \ublock{{\tt top}}{{\tt top}+{\tt topsize}}{\underscore} {}\\{}
*  (({\tt start}={\tt p}  *  B_1=\{\}){}\\{}
∨(∃q,m．\pinuse{\tt start}{1}  *  \block[*]{\tt start}{q}{B_1\uplusminus\{q+2{\sf w}↦m\}} {}\\{}
*  (m+1){\sf w} ≤ {\tt p}-q  *  \frac12(\size{q}{{\tt p}-q}) {}\\{}
*  \cinuse{q}{1}  *  {\tt p}-q ≥ 4{\sf w}  *  \iterstar[({\tt p}-q)/{\sf w}+1]{i=m+2}．q+i{\sf w}↦\underscore)) {}\\{}
*  \block[*]{{\tt p}+8{\tt i}}{\tt top}{B_2}  *  B_1 \uplus B_2 = A_{\sf a} \uplus (\biguplus_{i=0}^{64}．U_i)_{\sf u} {}\\{}
*  \frac12(\size{\tt p}{8{\tt i}})  *  \pinuse{{\tt p}+8{\tt idx}}{0}  *  \pinuse{\tt p}{1}  *  \cinuse{{\tt p}}{0} {}\\{}
*  \prevfoot{{\tt p}+8{\tt i}}{8{\tt i}}  *  \iterstar[2{\tt i}]{i=4}．{\tt p} + i{\sf w}↦\underscore {}\\{}
*  \texttt{least\_addr}=5{\sf w}  * n{\sf w} = \ceil[{\sf w}]{{\tt bytes}}   *  {\tt nb} = \max\{16,\ceil[8]{{\tt bytes}+4}\}  *  8{\tt i}≥(n+1){\sf w} {}\\{} *  2≤{\tt i}<32  *  \frac12(\size{\tt p}{8{\tt i}})  *  \fd{\tt p}{\underscore}   *  \bk{\tt p}{\underscore}  *  \iterstar[32]{i=0}．\smallbin{i}{U_i}  *  \iterstar[32]{i=0}．\treebin{i}{U_{i+32}}}£ 
          rsize = small_index2size(i) - nb;
          /* Fit here cannot be remainderless if 4byte sizes */
          if (SIZE_T_SIZE != 4 && rsize < MIN_CHUNK_SIZE)
            £\ass{\false}£
            set_inuse_and_pinuse(gm, p, small_index2size(i));
          else {
            £\ass{∃\{U_i\mid i∈[0,63)\},B_1,B_2,n．\coallesced{A_{\sf a} \uplus (\biguplus_{i=0}^{64}．U_i)_{\sf u}\uplus \{{\tt p}+2{\sf w}↦_{\sf u} 8{\tt i}-1{\sf w}\}} {}\\{} *  \prevfoot{\tt start}{\underscore}  *  \ublock{{\tt top}}{{\tt top}+{\tt topsize}}{\underscore} {}\\{}
*  (({\tt start}={\tt p}  *  B_1=\{\}){}\\{}
∨(∃q,m．\pinuse{\tt start}{1}  *  \block[*]{\tt start}{q}{B_1\uplusminus\{q+2{\sf w}↦m\}} {}\\{}
*  (m+1){\sf w} ≤ {\tt p}-q  *  \frac12(\size{q}{{\tt p}-q}) {}\\{}
*  \cinuse{q}{1}  *  {\tt p}-q ≥ 4{\sf w}  *  \iterstar[({\tt p}-q)/{\sf w}+1]{i=m+2}．q+i{\sf w}↦\underscore)) {}\\{}
*  \block[*]{{\tt p}+8{\tt i}}{\tt top}{B_2}  *  B_1 \uplus B_2 = A_{\sf a} \uplus (\biguplus_{i=0}^{64}．U_i)_{\sf u} {}\\{}
*  \frac12(\size{\tt p}{8{\tt i}})  *  \pinuse{{\tt p}+8{\tt idx}}{0}  *  \pinuse{\tt p}{1}  *  \cinuse{{\tt p}}{0} {}\\{}
*  \prevfoot{{\tt p}+8{\tt i}}{8{\tt i}}  *  \iterstar[2{\tt i}]{i=4}．{\tt p} + i{\sf w}↦\underscore {}\\{}
*  \texttt{least\_addr}=5{\sf w}  * n{\sf w} = \ceil[{\sf w}]{{\tt bytes}}   *  {\tt nb} = \max\{16,\ceil[8]{{\tt bytes}+4}\}  *  8{\tt i}≥(n+1){\sf w} {}\\{} *  2≤{\tt i}<32  *  \frac12(\size{\tt p}{8{\tt i}})  *  \fd{\tt p}{\underscore}   *  \bk{\tt p}{\underscore}  *  \iterstar[32]{i=0}．\smallbin{i}{U_i}  *  \iterstar[32]{i=0}．\treebin{i}{U_{i+32}} {}\\{}
*  {\tt rsize} = 8{\tt i} - {\tt nb}}£ 
            set_size_and_pinuse_of_inuse_chunk(gm, p, nb);
            r = chunk_plus_offset(p, nb);
            £\ass{∃\{U_i\mid i∈[0,63)\},B_1,B_2,n．\coallesced{A_{\sf a} \uplus (\biguplus_{i=0}^{64}．U_i)_{\sf u}\uplus \{{\tt p}+2{\sf w}↦_{\sf u} 8{\tt i}-1{\sf w}\}} {}\\{} *  \prevfoot{\tt start}{\underscore}  *  \ublock{{\tt top}}{{\tt top}+{\tt topsize}}{\underscore} {}\\{}
*  (({\tt start}={\tt p}  *  B_1=\{\}){}\\{}
∨(∃q,m．\pinuse{\tt start}{1}  *  \block[*]{\tt start}{q}{B_1\uplusminus\{q+2{\sf w}↦m\}} {}\\{}
*  (m+1){\sf w} ≤ {\tt p}-q  *  \frac12(\size{q}{{\tt p}-q}) {}\\{}
*  \cinuse{q}{1}  *  {\tt p}-q ≥ 4{\sf w}  *  \iterstar[({\tt p}-q)/{\sf w}+1]{i=m+2}．q+i{\sf w}↦\underscore)) {}\\{}
*  \block[*]{{\tt p}+8{\tt i}}{\tt top}{B_2}  *  B_1 \uplus B_2 = A_{\sf a} \uplus (\biguplus_{i=0}^{64}．U_i)_{\sf u} {}\\{}
*  \frac12(\size{\tt p}{\tt nb})  *  \pinuse{{\tt p}+8{\tt idx}}{0}  *  \pinuse{\tt p}{1}  *  \cinuse{{\tt p}}{1} {}\\{}
*  \prevfoot{{\tt p}+8{\tt i}}{8{\tt i}}  *  \iterstar[2{\tt i}]{i=4}．{\tt p} + i{\sf w}↦\underscore {}\\{}
*  \texttt{least\_addr}=5{\sf w}  * n{\sf w} = \ceil[{\sf w}]{{\tt bytes}}   *  {\tt nb} = \max\{16,\ceil[8]{{\tt bytes}+4}\}  *  8{\tt i}≥(n+1){\sf w} {}\\{} *  2≤{\tt i}<32  *  \frac12(\size{\tt p}{\tt nb})  *  \fd{\tt p}{\underscore}   *  \bk{\tt p}{\underscore}  *  \iterstar[32]{i=0}．\smallbin{i}{U_i}  *  \iterstar[32]{i=0}．\treebin{i}{U_{i+32}} {}\\{}
*  {\tt rsize} = 8{\tt i} - {\tt nb}  *  {\tt r} = {\tt p}+{\tt nb}}£

            £\ass{P_{small} ∧ P_{nb} ∧ flags({\tt p})=\setC\setP ∧ size(p)={\tt nb} ∧ {\tt rsize}=size(p)-{\tt nb} {}\\{}
            ∧ {\tt r}={\tt p}+{\tt nb}}£
            set_size_and_pinuse_of_free_chunk(r, rsize);
            £\ass{P_{small} ∧ P_{nb} ∧ flags({\tt p})=\setC\setP ∧ size(p)={\tt nb} ∧ {\tt rsize}=size(p)-{\tt nb} {}\\{} 
            ∧ {\tt r}={\tt p}+{\tt nb} ∧ flags({\tt r})=\unsetC\setP ∧ size({\tt r}) = {\tt rsize}}£
            replace_dv(gm, r, rsize);
            £\ass{P_{small} ∧ P_{nb} ∧ flags({\tt p})=\setC\setP ∧ size(p)={\tt nb} ∧ {\tt rsize}=size(p)-{\tt nb} {}\\{} 
            ∧ {\tt r}={\tt p}+{\tt nb} ∧ flags({\tt r})=\unsetC\setP ∧ size({\tt r}) = {\tt rsize} {}\\{}
            ∧ {\tt dv}={\tt r} ∧ {\tt dvsize}={\tt rsize}}£
          }
          mem = chunk2mem(p);
          check_malloced_chunk(gm, mem, nb);
          £\ass{P_{small} ∧ P_{nb} ∧ flags({\tt p})=\setC\setP ∧ size(p)={\tt nb} ∧ {\tt rsize}=size(p)-{\tt nb} {}\\{} 
          ∧ {\tt r}={\tt p}+{\tt nb} ∧ flags({\tt r})=\unsetC\setP ∧ size({\tt r}) = {\tt rsize} ∧ {\tt mem}={\tt p}+2}£
          goto postaction;
        }
\end{lstlisting}

\subsubsection*{Using a treebin instead}\label{sect:using_a_treebin_instead}

\begin{lstlisting}
        else if (gm->treemap != 0 && (mem = tmalloc_small(gm, nb)) != 0) {
          £\ass{P_{small} ∧ P_{nb} ∧ {\tt idx} = \floor{{\tt nb}/8} ∧ ∀i∈[{\tt idx},32)．smallbin(i)=∅ {}\\{}
          ∧ {\tt mem}=p+2 ∧ flags(p)=\setC\setP ∧ size(p) ≥ {\tt nb}}£
          check_malloced_chunk(gm, mem, nb);
          goto postaction;
        }
      }
    }
\end{lstlisting}

\subsection*{Allocating large chunks}\label{sect:allocating_large_chunks}

\begin{lstlisting}
    else if (bytes >= MAX_REQUEST)
      £\ass{{\tt bytes} ≥ 2^{32}-63}£
      nb = MAX_SIZE_T; /* Too big to allocate. Force failure (in sys alloc) */
      £\ass{{\tt nb} = 2^{32}-1}£
    else {
      £\ass{P_{large}} where $P_{large} = 244 < {\tt bytes} < 2^{32}-63$£
      nb = pad_request(bytes);
      £\ass{P_{large} ∧ P_{nb}}£
      if (gm->treemap != 0 && (mem = tmalloc_large(gm, nb)) != 0) {
        £\ass{P_{large} ∧ P_{nb} ∧ {\tt mem}=p+2 ∧ flags(p)=\setC\setP ∧ size(p) ≥ {\tt nb}}£
        check_malloced_chunk(gm, mem, nb);
        goto postaction;
      }
    }
\end{lstlisting}

\subsection*{Using the designated victim}\label{sect:using_the_designated_victim}

\begin{lstlisting}
    £\ass{P_{nb}}£
    if (nb <= gm->dvsize) {
      £\ass{P_{nb} ∧ {\tt nb}≤{\tt dvsize}}£
      size_t rsize = gm->dvsize - nb;
      £\ass{P_{nb} ∧ {\tt nb}≤{\tt dvsize} ∧ {\tt rsize}={\tt dvsize}-{\tt nb}}£
      mchunkptr p = gm->dv;
      £\ass{P_{nb} ∧ {\tt nb}≤size({\tt p}) ∧ {\tt rsize}=size({\tt p})-{\tt nb} ∧ flags({\tt p})=\unsetC\setP}£
      if (rsize >= MIN_CHUNK_SIZE) { /* split dv */
        £\ass{P_{nb} ∧ {\tt rsize}=size({\tt p})-{\tt nb} ∧ {\tt rsize}≥16 ∧ flags({\tt p})=\unsetC\setP}£
        mchunkptr r = gm->dv = chunk_plus_offset(p, nb);
        £\ass{P_{nb} ∧ {\tt rsize}=size({\tt p})-{\tt nb} ∧ {\tt rsize}≥16 ∧ {\tt r}={\tt p}+{\tt nb} ∧ flags({\tt p})=\unsetC\setP}£
        gm->dvsize = rsize;
        set_size_and_pinuse_of_free_chunk(r, rsize);
        £\ass{P_{nb} ∧ {\tt rsize}=size({\tt p})-{\tt nb} ∧ {\tt rsize}≥16 ∧ {\tt r}={\tt p}+{\tt nb} ∧ flags({\tt p})=\unsetC\setP {}\\{}
        ∧ flags({\tt r})=\unsetC\setP ∧ size({\tt r})={\tt rsize}}£
        set_size_and_pinuse_of_inuse_chunk(gm, p, nb);
        £\ass{P_{nb} ∧ {\tt rsize}≥16 ∧ {\tt r}={\tt p}+{\tt nb} ∧ flags({\tt p})=\setC\setP ∧ size(p)={\tt nb} {}\\{}
        ∧ flags({\tt r})=\unsetC\setP ∧ size({\tt r})={\tt rsize}}£
      }
      else { /* exhaust dv */
        £\ass{P_{nb} ∧ (size({\tt p})={\tt nb} ∨ size({\tt p})={\tt nb}+8) ∧ flags({\tt p})=\unsetC\setP}£
        size_t dvs = gm->dvsize;
        gm->dvsize = 0;
        gm->dv = 0;
        set_inuse_and_pinuse(gm, p, dvs);
        £\ass{P_{nb} ∧ (size({\tt p})={\tt nb} ∨ size({\tt p})={\tt nb}+8) ∧ flags({\tt p})=\setC\setP}£
      }
      £\ass{P_{nb} ∧ (size({\tt p})={\tt nb} ∨ size({\tt p})={\tt nb}+8) ∧ flags({\tt p})=\setC\setP}£
      mem = chunk2mem(p);
      check_malloced_chunk(gm, mem, nb);
      £\ass{P_{nb} ∧ (size({\tt p})={\tt nb} ∨ size({\tt p})={\tt nb}+8) ∧ flags({\tt p})=\setC\setP ∧ {\tt mem}={\tt p}+2}£
      goto postaction;
    }
\end{lstlisting}

\subsection*{Using the top chunk}

\begin{lstlisting}
    else if (nb < gm->topsize) { /* Split top */
      £\ass{ P_{nb} ∧ {\tt nb} < size({\tt top}) }£
      size_t rsize = gm->topsize -= nb;
      £\ass{ P_{nb} ∧ {\tt rsize}=size({\tt top})-{\tt nb} ∧ {\tt rsize}>0}£
      mchunkptr p = gm->top;
      £\ass{ P_{nb} ∧ {\tt rsize}=size({\tt p})-{\tt nb} ∧ {\tt rsize}>0}£
      mchunkptr r = gm->top = chunk_plus_offset(p, nb);
      £\ass{ P_{nb} ∧ {\tt rsize}=size({\tt p})-{\tt nb} ∧ {\tt rsize}>0 ∧ {\tt r}={\tt p}+{\tt nb}}£
      r->head = rsize | PINUSE_BIT;
      £\ass{ P_{nb} ∧ size({\tt r})=size({\tt p})-{\tt nb} ∧ size({\tt r})>0 ∧ flags({\tt r})=\unsetC\setP ∧ {\tt r}={\tt p}+{\tt nb}}£
      set_size_and_pinuse_of_inuse_chunk(gm, p, nb);
      £\ass{ P_{nb} ∧ size({\tt p})={\tt nb} ∧ flags({\tt p}) = \setC\setP ∧ size({\tt r})>0 ∧ flags({\tt r})=\unsetC\setP ∧ {\tt r}={\tt p}+{\tt nb}}£
      mem = chunk2mem(p);
      £\ass{ P_{nb} ∧ size({\tt p})={\tt nb} ∧ flags({\tt p}) = \setC\setP ∧ {\tt mem}={\tt p}+2}£
      check_top_chunk(gm, gm->top);
      check_malloced_chunk(gm, mem, nb);
      goto postaction;
    }
\end{lstlisting}

\subsection*{Obtaining memory from the system}

\begin{lstlisting}
    mem = sys_alloc(gm, nb);
  postaction:
    POSTACTION(gm);
    return mem;
  }
  return 0;
}
\end{lstlisting}

% \chapter{{\tt dlfree}}\label{chap:dlfree}

% \setcounter{lstnumber}{1}
% \begin{lstlisting}
% void dlfree(void* mem) {
%   if (mem != 0) {
%     mchunkptr p  = mem2chunk(mem);
% #if FOOTERS
%     mstate fm = get_mstate_for(p);
%     if (!ok_magic(fm)) {
%       USAGE_ERROR_ACTION(fm, p);
%       return;
%     }
% #else /* FOOTERS */
% #define fm gm
% #endif /* FOOTERS */
%     if (!PREACTION(fm)) {
%       check_inuse_chunk(fm, p);
%       if (RTCHECK(ok_address(fm, p) && ok_inuse(p))) {
%         size_t psize = chunksize(p);
%         mchunkptr next = chunk_plus_offset(p, psize);
%         if (!pinuse(p)) {
%           size_t prevsize = p->prev_foot;
%           if (is_mmapped(p)) {
%             psize += prevsize + MMAP_FOOT_PAD;
%             if (CALL_MUNMAP((char*)p - prevsize, psize) == 0)
%               fm->footprint -= psize;
%             goto postaction;
%           }
%           else {
%             mchunkptr prev = chunk_minus_offset(p, prevsize);
%             psize += prevsize;
%             p = prev;
%             if (RTCHECK(ok_address(fm, prev))) { /* consolidate backward */
%               if (p != fm->dv) {
%                 unlink_chunk(fm, p, prevsize);
%               }
%               else if ((next->head & INUSE_BITS) == INUSE_BITS) {
%                 fm->dvsize = psize;
%                 set_free_with_pinuse(p, psize, next);
%                 goto postaction;
%               }
%             }
%             else
%               goto erroraction;
%           }
%         }

%         if (RTCHECK(ok_next(p, next) && ok_pinuse(next))) {
%           if (!cinuse(next)) {  /* consolidate forward */
%             if (next == fm->top) {
%               size_t tsize = fm->topsize += psize;
%               fm->top = p;
%               p->head = tsize | PINUSE_BIT;
%               if (p == fm->dv) {
%                 fm->dv = 0;
%                 fm->dvsize = 0;
%               }
%               if (should_trim(fm, tsize))
%                 sys_trim(fm, 0);
%               goto postaction;
%             }
%             else if (next == fm->dv) {
%               size_t dsize = fm->dvsize += psize;
%               fm->dv = p;
%               set_size_and_pinuse_of_free_chunk(p, dsize);
%               goto postaction;
%             }
%             else {
%               size_t nsize = chunksize(next);
%               psize += nsize;
%               unlink_chunk(fm, next, nsize);
%               set_size_and_pinuse_of_free_chunk(p, psize);
%               if (p == fm->dv) {
%                 fm->dvsize = psize;
%                 goto postaction;
%               }
%             }
%           }
%           else
%             set_free_with_pinuse(p, psize, next);

%           if (is_small(psize)) {
%             insert_small_chunk(fm, p, psize);
%             check_free_chunk(fm, p);
%           }
%           else {
%             tchunkptr tp = (tchunkptr)p;
%             insert_large_chunk(fm, tp, psize);
%             check_free_chunk(fm, p);
%             if (--fm->release_checks == 0)
%               release_unused_segments(fm);
%           }
%           goto postaction;
%         }
%       }
%     erroraction:
%       USAGE_ERROR_ACTION(fm, p);
%     postaction:
%       POSTACTION(fm);
%     }
%   }
% #if !FOOTERS
% #undef fm
% #endif /* FOOTERS */
% }
% \end{lstlisting}

\end{document}